## API Report File for "@contember/binding-common"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ContentQueryBuilder } from '@contember/client-content';
import { EmbeddedActionsParser } from 'chevrotain';
import { v4 as generateUuid } from 'uuid';
import type { GraphQlClient } from '@contember/client';
import type { GraphQlClientRequestOptions } from '@contember/client';
import { Input } from '@contember/client';
import { MutationResult } from '@contember/client';
import type { Result } from '@contember/client';
import { TokenType } from 'chevrotain';
import { TransactionResult } from '@contember/client';

// @public (undocumented)
export type Alias = string;

// @public (undocumented)
export function assertNever(_: never): never;

// @public (undocumented)
export interface AsyncBatchUpdatesOptions extends BatchUpdatesOptions {
    // (undocumented)
    contentClient: GraphQlClient;
    // (undocumented)
    systemClient: GraphQlClient;
    // (undocumented)
    tenantClient: GraphQlClient;
}

// @public (undocumented)
export interface BaseRelation {
    // (undocumented)
    __typename: '_Relation';
    // (undocumented)
    deprecationReason: string | null;
    // (undocumented)
    description: string | null;
    // (undocumented)
    name: FieldName;
    // (undocumented)
    nullable: boolean | null;
    // (undocumented)
    onDelete: 'restrict' | 'cascade' | 'setNull' | null;
    // (undocumented)
    orderBy: SchemaRelationOrderBy[] | null;
    // (undocumented)
    orphanRemoval: boolean | null;
    // (undocumented)
    targetEntity: EntityName;
    // (undocumented)
    type: 'OneHasOne' | 'OneHasMany' | 'ManyHasOne' | 'ManyHasMany';
}

// @public (undocumented)
export type BatchDeferredUpdates = (performUpdates: (bindingOperations: BatchUpdatesOptions) => void) => void;

// @public (undocumented)
export interface BatchUpdatesOptions {
    // (undocumented)
    getEntityByKey: GetEntityByKey;
    // (undocumented)
    getEntityListSubTree: GetEntityListSubTree;
    // (undocumented)
    getEntitySubTree: GetEntitySubTree;
}

// @public (undocumented)
export class BindingError extends Error {
}

// @public (undocumented)
export interface BindingOperations<Node> extends AsyncBatchUpdatesOptions {
    // (undocumented)
    addEventListener: <Type extends keyof DataBindingEventListenerMap>(event: Type, listener: DataBindingEventListenerMap[Type]) => () => void;
    // (undocumented)
    batchDeferredUpdates: BatchDeferredUpdates;
    // (undocumented)
    extendTree: ExtendTree<Node>;
    // (undocumented)
    fetchData: FetchData<Node>;
    // (undocumented)
    persist: Persist;
}

// @public (undocumented)
export class ClientGeneratedUuid implements RuntimeIdSpec {
    constructor(value: string);
    // (undocumented)
    get existsOnServer(): false;
    // (undocumented)
    get uniqueValue(): UniqueEntityId;
    // (undocumented)
    readonly value: string;
}

// @public (undocumented)
export const createQueryBuilder: (schema: Schema) => ContentQueryBuilder;

// @public (undocumented)
export type DataBindingEventListenerMap = {
    persistSuccess: (result: SuccessfulPersistResult) => void | Promise<void>;
    persistError: (result: ErrorPersistResult) => void | Promise<void>;
};

// @public (undocumented)
export const DataBindingExtendAborted: unique symbol;

// @public (undocumented)
export type DataBindingTransactionResult = TransactionResult<Record<string, MutationResult<ReceivedEntityData>>>;

// @public (undocumented)
export interface EntityAccessor extends Errorable {
    // (undocumented)
    readonly __type: 'EntityAccessor';
    // (undocumented)
    addError: ErrorAccessor.AddError;
    // (undocumented)
    addEventListener: EntityAccessor.AddEventListener;
    // (undocumented)
    batchUpdates(performUpdates: EntityAccessor.BatchUpdatesHandler): void;
    // (undocumented)
    connectEntityAtField(field: SugaredRelativeSingleEntity | string, entityToConnect: EntityAccessor): void;
    // (undocumented)
    deleteEntity(): void;
    // (undocumented)
    disconnectEntityAtField(field: SugaredRelativeSingleEntity | string, initializeReplacement?: EntityAccessor.BatchUpdatesHandler): void;
    // (undocumented)
    readonly environment: Environment;
    // (undocumented)
    readonly errors: ErrorAccessor | undefined;
    // (undocumented)
    readonly existsOnServer: boolean;
    // (undocumented)
    readonly getAccessor: EntityAccessor.GetEntityAccessor;
    // (undocumented)
    getEntity(entity: SugaredRelativeSingleEntity | string | RelativeSingleEntity): EntityAccessor;
    // (undocumented)
    getEntityList(entityList: SugaredRelativeEntityList | string | RelativeEntityList): EntityListAccessor;
    getField<Value extends FieldValue = FieldValue>(field: SugaredRelativeSingleField | string | RelativeSingleField): FieldAccessor<Value>;
    // (undocumented)
    getFieldMeta(field: string): {
        readable?: boolean;
        updatable?: boolean;
    };
    // (undocumented)
    getMarker(): HasManyRelationMarker | HasOneRelationMarker | EntitySubTreeMarker | EntityListSubTreeMarker;
    // (undocumented)
    getParent(): EntityAccessor | EntityListAccessor | undefined;
    // (undocumented)
    readonly hasUnpersistedChanges: boolean;
    // (undocumented)
    readonly id: EntityId;
    // (undocumented)
    readonly idOnServer: EntityId | undefined;
    readonly key?: EntityRealmKey;
    // (undocumented)
    readonly name: EntityName;
    // (undocumented)
    updateValues(fieldValuePairs: EntityAccessor.FieldValuePairs): void;
}

// @public (undocumented)
export namespace EntityAccessor {
    // (undocumented)
    export type AddEventListener = <Type extends keyof EntityAccessor.RuntimeEntityEventListenerMap>(event: {
        type: Type;
        key?: string;
    }, listener: EntityAccessor.EntityEventListenerMap[Type]) => () => void;
    // (undocumented)
    export type BatchUpdatesHandler = (getAccessor: GetEntityAccessor, options: BatchUpdatesOptions) => void;
    // (undocumented)
    export type BeforePersistHandler = (getAccessor: GetEntityAccessor, options: AsyncBatchUpdatesOptions) => void | BeforePersistHandler | Promise<void | BeforePersistHandler>;
    // (undocumented)
    export type EntityEventListenerMap = RuntimeEntityEventListenerMap & {
        initialize: BatchUpdatesHandler;
    };
    // (undocumented)
    export type EntityEventType = keyof EntityEventListenerMap;
    // (undocumented)
    export type FieldData = Map<FieldName, FieldDatum>;
    // (undocumented)
    export interface FieldDatum {
        // (undocumented)
        getAccessor(): NestedAccessor;
    }
    // (undocumented)
    export type FieldValuePairs = {
        [field: string]: FieldValue;
    } | Iterable<[SugaredRelativeSingleField | string, FieldValue]>;
    // (undocumented)
    export type GetEntityAccessor = () => EntityAccessor;
    // (undocumented)
    export type NestedAccessor = EntityAccessor | EntityListAccessor | FieldAccessor<any>;
    // (undocumented)
    export type PersistErrorHandler = (getAccessor: GetEntityAccessor, options: PersistErrorOptions) => void | Promise<void>;
    // (undocumented)
    export type PersistSuccessHandler = (getAccessor: GetEntityAccessor, options: PersistSuccessOptions) => void | PersistSuccessHandler | Promise<void | PersistSuccessHandler>;
    // (undocumented)
    export type RuntimeEntityEventListenerMap = {
        beforePersist: BeforePersistHandler;
        beforeUpdate: BatchUpdatesHandler;
        connectionUpdate: UpdateListener;
        persistError: PersistErrorHandler;
        persistSuccess: PersistSuccessHandler;
        update: UpdateListener;
    };
    // (undocumented)
    export type UpdateListener = (accessor: EntityAccessor) => void;
}

// @public (undocumented)
export const EntityCreationParametersDefaults: {
    readonly isNonbearing: false;
};

// @public (undocumented)
export type EntityEventListenerStore = EventListenersStore<EntityAccessor.EntityEventListenerMap>;

// @public (undocumented)
export type EntityFieldMarker = FieldMarker | HasOneRelationMarker | HasManyRelationMarker;

// @public (undocumented)
export type EntityFieldMarkers = ReadonlyMap<PlaceholderName, EntityFieldMarker>;

// @public (undocumented)
export class EntityFieldMarkersContainer {
    constructor(hasAtLeastOneBearingField: boolean, markers: EntityFieldMarkers, // Indexed by placeholder names
    placeholders: EntityFieldPlaceholders);
    // (undocumented)
    readonly hasAtLeastOneBearingField: boolean;
    // (undocumented)
    readonly markers: EntityFieldMarkers;
    // (undocumented)
    readonly placeholders: EntityFieldPlaceholders;
}

// @public (undocumented)
export type EntityFieldPlaceholders = ReadonlyMap<FieldName, PlaceholderName | Set<PlaceholderName>>;

// @public (undocumented)
export class EntityFieldsWithHoistablesMarker {
    constructor(fields: EntityFieldMarkersContainer, subTrees: SubTreeMarkers | undefined, parentReference: ParentEntityParameters | undefined);
    // (undocumented)
    readonly fields: EntityFieldMarkersContainer;
    // (undocumented)
    readonly parentReference: ParentEntityParameters | undefined;
    // (undocumented)
    readonly subTrees: SubTreeMarkers | undefined;
}

// @public (undocumented)
export type EntityId = string | number;

// @public (undocumented)
export interface EntityListAccessor extends Errorable {
    // (undocumented)
    [Symbol.iterator](): IterableIterator<EntityAccessor>;
    // (undocumented)
    readonly __type: 'EntityListAccessor';
    // (undocumented)
    addChildEventListener: EntityListAccessor.AddChildEventListener;
    // (undocumented)
    addError(error: ErrorAccessor.Error | string): () => void;
    // (undocumented)
    addEventListener: EntityListAccessor.AddEventListener;
    // (undocumented)
    batchUpdates(performUpdates: EntityListAccessor.BatchUpdatesHandler): void;
    // (undocumented)
    connectEntity(entityToConnect: EntityAccessor): void;
    // (undocumented)
    createNewEntity(initialize?: EntityAccessor.BatchUpdatesHandler): RuntimeId;
    // (undocumented)
    deleteAll(): void;
    // (undocumented)
    disconnectAll(): void;
    // (undocumented)
    disconnectEntity(childEntity: EntityAccessor, options?: {
        noPersist?: boolean;
    }): void;
    // (undocumented)
    readonly environment: Environment;
    // (undocumented)
    readonly errors: ErrorAccessor | undefined;
    // (undocumented)
    readonly getAccessor: EntityListAccessor.GetEntityListAccessor;
    // (undocumented)
    getChildEntityById(id: EntityId): EntityAccessor;
    // (undocumented)
    getMarker(): EntityListSubTreeMarker | HasManyRelationMarker;
    // (undocumented)
    getParent(): EntityAccessor | undefined;
    // (undocumented)
    hasEntityId(id: EntityId): boolean;
    // (undocumented)
    readonly hasUnpersistedChanges: boolean;
    // (undocumented)
    ids(): IterableIterator<EntityId>;
    idsPersistedOnServer: Set<EntityId>;
    // (undocumented)
    isEmpty(): boolean;
    keys(): IterableIterator<EntityRealmKey>;
    // (undocumented)
    length: number;
    // (undocumented)
    readonly name: EntityName;
}

// @public (undocumented)
export namespace EntityListAccessor {
    // (undocumented)
    export type AddChildEventListener = <Type extends keyof EntityAccessor.EntityEventListenerMap>(event: {
        type: Type;
        key?: string;
    }, listener: EntityAccessor.EntityEventListenerMap[Type]) => () => void;
    // (undocumented)
    export type AddEventListener = <Type extends keyof EntityListAccessor.RuntimeEntityListEventListenerMap>(event: {
        type: Type;
        key?: string;
    }, listener: EntityListAccessor.EntityListEventListenerMap[Type]) => () => void;
    // (undocumented)
    export type BatchUpdatesHandler = (getAccessor: GetEntityListAccessor, options: BatchUpdatesOptions) => void;
    // (undocumented)
    export type BeforePersistHandler = (getAccessor: GetEntityListAccessor, options: AsyncBatchUpdatesOptions) => void | Promise<void | BeforePersistHandler>;
    // (undocumented)
    export type ChildEventListenerMap = {
        childBeforeUpdate: EntityAccessor.BatchUpdatesHandler;
        childInitialize: EntityAccessor.BatchUpdatesHandler;
        childUpdate: EntityAccessor.UpdateListener;
    };
    // (undocumented)
    export type EntityListEventListenerMap = RuntimeEntityListEventListenerMap & {
        initialize: BatchUpdatesHandler;
    };
    // (undocumented)
    export type EntityListEventType = keyof EntityListEventListenerMap;
    // (undocumented)
    export type GetEntityListAccessor = () => EntityListAccessor;
    // (undocumented)
    export type PersistErrorHandler = (getAccessor: GetEntityListAccessor, options: PersistErrorOptions) => void | Promise<void>;
    // (undocumented)
    export type PersistSuccessHandler = (getAccessor: GetEntityListAccessor, options: PersistSuccessOptions) => void | Promise<void | PersistSuccessHandler>;
    // (undocumented)
    export type RuntimeEntityListEventListenerMap = {
        beforePersist: BeforePersistHandler;
        beforeUpdate: BatchUpdatesHandler;
        persistError: PersistErrorHandler;
        persistSuccess: PersistSuccessHandler;
        update: UpdateListener;
    };
    // (undocumented)
    export type UpdateListener = (accessor: EntityListAccessor) => void;
}

// @public (undocumented)
export type EntityListEventListenerStore = EventListenersStore<EntityListAccessor.EntityListEventListenerMap>;

// @public (undocumented)
export const EntityListPreferencesDefaults: {
    initialEntityCount: number;
};

// @public (undocumented)
export class EntityListSubTreeMarker {
    constructor(parameters: QualifiedEntityList | UnconstrainedQualifiedEntityList, fields: EntityFieldMarkersContainer, environment: Environment);
    // (undocumented)
    get entityName(): string;
    // (undocumented)
    readonly environment: Environment;
    // (undocumented)
    readonly fields: EntityFieldMarkersContainer;
    // (undocumented)
    readonly parameters: QualifiedEntityList | UnconstrainedQualifiedEntityList;
    // (undocumented)
    readonly placeholderName: string;
}

// @public (undocumented)
export type EntityName = string;

// @public (undocumented)
export type EntityRealmKey = string;

// @public (undocumented)
export class EntitySubTreeMarker {
    constructor(parameters: QualifiedSingleEntity | UnconstrainedQualifiedSingleEntity, fields: EntityFieldMarkersContainer, environment: Environment);
    // (undocumented)
    get entityName(): string;
    // (undocumented)
    readonly environment: Environment;
    // (undocumented)
    readonly fields: EntityFieldMarkersContainer;
    // (undocumented)
    readonly parameters: QualifiedSingleEntity | UnconstrainedQualifiedSingleEntity;
    // (undocumented)
    readonly placeholderName: string;
}

// @public (undocumented)
export class Environment<Node extends Environment.AnyNode | undefined = Environment.AnyNode | undefined> {
    // (undocumented)
    static create(): Environment<Environment.AnyNode | undefined>;
    // (undocumented)
    getAllDimensions(): Environment.SelectedDimensions;
    // (undocumented)
    getAllParameters(): Environment.Parameters;
    // (undocumented)
    getAllVariables(): Environment.CustomVariables;
    // (undocumented)
    getDimension<F>(dimensionName: string): string[];
    // (undocumented)
    getDimensionOrElse<F>(dimensionName: string, fallback: F): string[] | F;
    // (undocumented)
    getExtension<S, R>(extension: Environment.Extension<S, R>): R;
    // (undocumented)
    getParameter<F>(key: string): string | number;
    // (undocumented)
    getParameterOrElse<F>(key: string, fallback: F): string | number | F;
    // (undocumented)
    getParent(): Environment;
    // (undocumented)
    getSchema(): Schema;
    // (undocumented)
    getSubTree(): Environment.SubTreeNode;
    // (undocumented)
    getSubTreeNode(): Node & Environment.AnyNode;
    // (undocumented)
    getVariable<V extends Environment.Value = Environment.Value>(key: string): V;
    // (undocumented)
    getVariableOrElse<F, V extends Environment.Value = Environment.Value>(key: string, fallback: F): V | F;
    // (undocumented)
    hasDimension(dimensionName: string): boolean;
    // (undocumented)
    hasParameter(key: string): boolean;
    // (undocumented)
    hasSchema(): boolean;
    // (undocumented)
    hasVariable(key: string): boolean;
    // (undocumented)
    merge(other: Environment): Environment;
    // (undocumented)
    withDimensions(dimensions: Environment.SelectedDimensions): Environment;
    // (undocumented)
    withExtension<S, R>(extension: Environment.Extension<S, R>, state: S): Environment;
    // (undocumented)
    withParameters(parameters: Environment.Parameters): Environment;
    // (undocumented)
    withSchema(schema: Schema): Environment;
    // (undocumented)
    withSubTree<Node extends Environment.SubTreeNode>(SubTree: Node): Environment<Node>;
    // (undocumented)
    withSubTreeChild<Node extends Environment.InnerNode>(node: Node): Environment<Node>;
    // (undocumented)
    withVariables(variables: Environment.ValuesMapWithFactory | undefined): Environment;
}

// @public (undocumented)
export namespace Environment {
    // (undocumented)
    export type AnyNode = SubTreeNode | InnerNode;
    // (undocumented)
    export interface ColumnNode {
        // (undocumented)
        entity: SchemaEntity;
        // (undocumented)
        field: SchemaColumn;
        // (undocumented)
        type: 'column';
    }
    // (undocumented)
    export interface CustomVariables {
        // (undocumented)
        [key: string]: Value;
    }
    // (undocumented)
    export interface EntityListNode {
        // (undocumented)
        entity: SchemaEntity;
        // (undocumented)
        field: SchemaRelation;
        // (undocumented)
        type: 'entity-list';
    }
    // (undocumented)
    export interface EntityNode {
        // (undocumented)
        entity: SchemaEntity;
        // (undocumented)
        field: SchemaRelation;
        // (undocumented)
        type: 'entity';
    }
    // (undocumented)
    export type Extension<State, Result> = {
        create: (state: State | undefined, environment: Environment) => Result;
    };
    // (undocumented)
    export type InnerNode = EntityNode | EntityListNode | ColumnNode;
    // (undocumented)
    export type Name = string;
    // (undocumented)
    export interface Options<Node extends AnyNode | undefined> {
        // (undocumented)
        dimensions: SelectedDimensions;
        // (undocumented)
        extensions: Map<Extension<unknown, unknown>, unknown>;
        // (undocumented)
        node?: Node;
        // (undocumented)
        parameters: Parameters;
        // (undocumented)
        parent?: Environment;
        // (undocumented)
        schema?: Schema;
        // (undocumented)
        variables: CustomVariables;
    }
    // (undocumented)
    export type Parameters = {
        [K in string]?: string | number;
    };
    // (undocumented)
    export type ResolvedValue = Value;
    // (undocumented)
    export interface SelectedDimensions {
        // (undocumented)
        [key: string]: string[];
    }
    // (undocumented)
    export interface SubTreeEntityListNode {
        // (undocumented)
        entity: SchemaEntity;
        // (undocumented)
        expectedCardinality: 'zero-to-many' | 'zero';
        // (undocumented)
        filter: Filter;
        // (undocumented)
        type: 'subtree-entity-list';
    }
    // (undocumented)
    export interface SubTreeEntityNode {
        // (undocumented)
        entity: SchemaEntity;
        // (undocumented)
        expectedCardinality: 'zero' | 'one' | 'zero-or-one';
        // (undocumented)
        filter: Filter;
        // (undocumented)
        type: 'subtree-entity';
    }
    // (undocumented)
    export type SubTreeNode = SubTreeEntityNode | SubTreeEntityListNode;
    // (undocumented)
    export type Value = unknown;
    // (undocumented)
    export interface ValuesMapWithFactory {
        // (undocumented)
        [key: string]: ((environment: Environment) => Value) | Value;
    }
    const // (undocumented)
    createExtension: <S, R>(create: Extension<S, R>["create"], otherMethods?: Omit<Extension<S, R>, "create">) => Extension<S, R>;
}

// @public (undocumented)
export interface Errorable {
    // (undocumented)
    errors: ErrorAccessor | undefined;
}

// @public (undocumented)
export interface ErrorAccessor {
    // (undocumented)
    readonly errors: ErrorAccessor.Error[];
}

// @public (undocumented)
export namespace ErrorAccessor {
    // (undocumented)
    export type AddError = (error: ErrorAccessor.Error | string) => ClearError;
    // (undocumented)
    export type ClearError = () => void;
    // (undocumented)
    export type Error = ExecutionError | ValidationError;
    // (undocumented)
    export type ErrorId = number;
    // (undocumented)
    export type ErrorsById = Map<ErrorId, Error>;
    // (undocumented)
    export interface ExecutionError {
        // (undocumented)
        code: Result.ExecutionErrorType;
        // (undocumented)
        developerMessage: string | null;
        // (undocumented)
        type: 'execution';
    }
    // (undocumented)
    export type ExecutionErrors = ExecutionError[];
    // (undocumented)
    export interface ValidationError {
        // (undocumented)
        code: WellKnownErrorCode | string | undefined;
        // (undocumented)
        message: string;
        // (undocumented)
        type: 'validation';
    }
    // (undocumented)
    export type ValidationErrors = ValidationError[];
    // (undocumented)
    export type WellKnownErrorCode = 'fieldRequired';
    const // (undocumented)
    normalizeError: (error: Error | string) => Error;
}

// @public (undocumented)
export interface ErrorAccessorHolder {
    // (undocumented)
    readonly errors: ErrorAccessor | undefined;
}

// @public (undocumented)
export type ErrorPersistResult = InvalidInputPersistResult | InvalidResponseResult;

// @public (undocumented)
export class EventListenersStore<Events extends GenericEventsMap> {
    constructor(parentStoreGetter?: (() => EventListenersStore<Events> | undefined) | undefined, listeners?: Map<string, Set<Events[any]>> | undefined);
    // (undocumented)
    add<Type extends keyof Events>(event: {
        type: Type;
        key?: string;
    }, handler: Events[Type]): () => void;
    // (undocumented)
    append(other: EventListenersStore<Events>): void;
    // (undocumented)
    clone(): EventListenersStore<Events>;
    // (undocumented)
    delete<Type extends keyof Events>(event: {
        type: Type;
        key?: string;
    }): void;
    // (undocumented)
    deleteByType<Type extends keyof Events>(type: Type): void;
    // (undocumented)
    get<Type extends keyof Events>(event: {
        type: Type;
        key?: string;
    }): Set<Events[Type]> | undefined;
    // (undocumented)
    invoke<Type extends keyof Events>(event: {
        type: Type;
        key?: string;
    }, ...args: Parameters<Events[Type]>): void;
    // (undocumented)
    set<Type extends keyof Events>(event: {
        type: Type;
        key?: string;
    }, listeners: Set<Events[Type]>): void;
}

// @public (undocumented)
export type ExpectedEntityCount = 'upToOne' | 'possiblyMany';

// @public (undocumented)
export type ExpectedQualifiedEntityMutation = 'none' | 'anyMutation';

// @public (undocumented)
export type ExpectedRelationMutation = 'none' | 'createOrDelete' | 'connectOrDisconnect' | 'anyMutation';

// @public (undocumented)
export type ExtendTree<Node> = (newFragment: Node, options?: ExtendTreeOptions) => Promise<TreeRootId | undefined>;

// @public (undocumented)
export interface ExtendTreeOptions {
    // (undocumented)
    environment?: Environment;
    // (undocumented)
    force?: boolean;
    // (undocumented)
    onError?: (error: Error) => void;
    // (undocumented)
    signal?: AbortSignal;
}

// @public (undocumented)
export type FetchData<Node> = (fragment: Node, options?: {
    signal?: AbortSignal;
    environment?: Environment;
}) => Promise<{
    data: ReceivedDataTree;
    markerTreeRoot: MarkerTreeRoot;
}>;

// @public (undocumented)
export interface FieldAccessor<Value extends FieldValue = FieldValue> extends Errorable {
    // (undocumented)
    readonly __type: 'FieldAccessor';
    // (undocumented)
    addError(error: ErrorAccessor.Error | string): ErrorAccessor.ClearError;
    // (undocumented)
    addEventListener: FieldAccessor.AddEventListener<Value>;
    // (undocumented)
    clearErrors(): void;
    // (undocumented)
    readonly defaultValue: Value | undefined;
    // (undocumented)
    readonly errors: ErrorAccessor | undefined;
    // (undocumented)
    readonly fieldName: FieldName;
    // (undocumented)
    readonly getAccessor: FieldAccessor.GetFieldAccessor<Value>;
    // (undocumented)
    getParent(): EntityAccessor;
    // (undocumented)
    readonly hasUnpersistedChanges: boolean;
    // (undocumented)
    isTouched: boolean;
    // (undocumented)
    isTouchedBy(agent: FieldAccessor.TouchAgent): boolean;
    // (undocumented)
    readonly schema: SchemaColumn;
    // (undocumented)
    updateValue(newValue: Value | null, options?: FieldAccessor.UpdateOptions): void;
    // (undocumented)
    readonly value: Value | null;
    // (undocumented)
    readonly valueOnServer: Value | null;
}

// @public (undocumented)
export namespace FieldAccessor {
    // (undocumented)
    export type AddEventListener<Value extends FieldValue = FieldValue> = <Type extends FieldEventType>(event: {
        type: Type;
        key?: string;
    }, listener: FieldEventListenerMap<Value>[Type]) => () => void;
    // (undocumented)
    export type BeforeUpdateListener<Value extends FieldValue = FieldValue> = (updatedAccessor: FieldAccessor<Value>) => void;
    // (undocumented)
    export type FieldEventListenerMap<Value extends FieldValue = FieldValue> = RuntimeFieldEventListenerMap<Value> & {
        initialize: InitializeListener<Value>;
    };
    // (undocumented)
    export type FieldEventType = keyof FieldEventListenerMap;
    // (undocumented)
    export type GetFieldAccessor<Value extends FieldValue = FieldValue> = () => FieldAccessor<Value>;
    // (undocumented)
    export type InitializeListener<Value extends FieldValue = FieldValue> = (getAccessor: GetFieldAccessor<Value>, options: BatchUpdatesOptions) => void;
    // (undocumented)
    export type RuntimeFieldEventListenerMap<Value extends FieldValue = FieldValue> = {
        beforeUpdate: BeforeUpdateListener<Value>;
        update: UpdateListener<Value>;
    };
    // (undocumented)
    export type TouchAgent = 'user' | (string & {});
    // (undocumented)
    export type UpdateListener<Value extends FieldValue = FieldValue> = (accessor: FieldAccessor<Value>) => void;
    // (undocumented)
    export interface UpdateOptions {
        // (undocumented)
        agent?: TouchAgent;
    }
}

// @public (undocumented)
export type FieldEventListenerStore<Value extends FieldValue = FieldValue> = EventListenersStore<FieldAccessor.FieldEventListenerMap<Value>>;

// @public
export class FieldMarker {
    constructor(parameters: Omit<RelativeSingleField, 'hasOneRelationPath'>);
    // (undocumented)
    get defaultValue(): FieldValue | undefined;
    // (undocumented)
    get fieldName(): FieldName;
    // (undocumented)
    get isNonbearing(): boolean;
    // (undocumented)
    readonly parameters: Omit<RelativeSingleField, 'hasOneRelationPath'>;
    // (undocumented)
    readonly placeholderName: string;
}

// @public (undocumented)
export type FieldMeta = ('readable' | 'updatable')[];

// @public (undocumented)
export type FieldName = string;

// @public (undocumented)
export type FieldValue = JsonValue;

// @public (undocumented)
export type Filter<T = never> = Input.Where<Input.Condition<Input.ColumnValue<T>>>;

export { generateUuid }

// Warning: (ae-forgotten-export) The symbol "AnyFunction" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type GenericEventsMap = {
    [K in string]: (...args: any[]) => void | AnyFunction | Promise<void | AnyFunction>;
};

// @public (undocumented)
export type GetEntityByKey = (key: string | (() => EntityAccessor)) => EntityAccessor;

// @public (undocumented)
export type GetEntityListSubTree = (parametersOrAlias: Alias | SugaredQualifiedEntityList | SugaredUnconstrainedQualifiedEntityList, treeId?: TreeRootId, environment?: Environment) => EntityListAccessor;

// @public (undocumented)
export type GetEntitySubTree = (parametersOrAlias: Alias | SugaredQualifiedSingleEntity | SugaredUnconstrainedQualifiedSingleEntity, treeId?: TreeRootId, environment?: Environment) => EntityAccessor;

// @public (undocumented)
export interface HasManyRelation {
    // (undocumented)
    childEventListeners: EntityEventListenerStore | undefined;
    // (undocumented)
    eventListeners: EntityListEventListenerStore | undefined;
    // (undocumented)
    expectedMutation: ExpectedRelationMutation;
    // (undocumented)
    field: FieldName;
    // (undocumented)
    filter: Filter | undefined;
    // (undocumented)
    initialEntityCount: number;
    // (undocumented)
    isNonbearing: boolean;
    // (undocumented)
    limit: Limit | undefined;
    // (undocumented)
    meta: FieldMeta;
    // (undocumented)
    offset: Offset | undefined;
    // (undocumented)
    orderBy: OrderBy | undefined;
    // (undocumented)
    setOnCreate: SetOnCreate;
}

// @public (undocumented)
export class HasManyRelationMarker {
    constructor(parameters: HasManyRelation, fields: EntityFieldMarkersContainer, environment: Environment);
    // (undocumented)
    readonly environment: Environment;
    // (undocumented)
    readonly fields: EntityFieldMarkersContainer;
    // (undocumented)
    get isNonbearing(): boolean;
    // (undocumented)
    readonly parameters: HasManyRelation;
    // (undocumented)
    readonly placeholderName: string;
}

// @public (undocumented)
export interface HasOneRelation {
    // (undocumented)
    eventListeners: EntityEventListenerStore | undefined;
    // (undocumented)
    expectedMutation: ExpectedRelationMutation;
    // (undocumented)
    field: FieldName;
    // (undocumented)
    filter: Filter | undefined;
    // (undocumented)
    isNonbearing: boolean;
    // (undocumented)
    meta: FieldMeta;
    // (undocumented)
    reducedBy: UniqueWhere | undefined;
    // (undocumented)
    setOnCreate: SetOnCreate;
}

// @public (undocumented)
export class HasOneRelationMarker {
    constructor(parameters: HasOneRelation, fields: EntityFieldMarkersContainer, environment: Environment);
    // (undocumented)
    readonly environment: Environment;
    // (undocumented)
    readonly fields: EntityFieldMarkersContainer;
    // (undocumented)
    get isNonbearing(): boolean;
    // (undocumented)
    readonly parameters: HasOneRelation;
    // (undocumented)
    readonly placeholderName: string;
}

// @public (undocumented)
export interface InvalidInputPersistResult {
    // (undocumented)
    errors: ErrorAccessor.Error[];
    // (undocumented)
    response?: DataBindingTransactionResult;
    // (undocumented)
    type: 'invalidInput';
}

// @public (undocumented)
export interface InvalidResponseResult {
    // (undocumented)
    errors: any;
    // (undocumented)
    type: 'invalidResponse';
}

// @public (undocumented)
export interface InverseRelation extends BaseRelation {
    // (undocumented)
    inversedBy?: never;
    // (undocumented)
    ownedBy: FieldName;
    // (undocumented)
    side: 'inverse';
}

// @public (undocumented)
export const isEntityAccessor: (accessor: unknown) => accessor is EntityAccessor;

// @public (undocumented)
export const isEntityListAccessor: (accessor: unknown) => accessor is EntityListAccessor;

// @public (undocumented)
export const isErrorPersistResult: (result: unknown) => result is ErrorPersistResult;

// @public (undocumented)
export const isFieldAccessor: (accessor: unknown) => accessor is FieldAccessor;

// @public (undocumented)
export interface JsonArray<Ext = never> extends Array<JsonValue<Ext>> {
}

// @public (undocumented)
export interface JsonObject<Ext = never> {
    // (undocumented)
    [key: string]: JsonValue<Ext>;
}

// @public (undocumented)
export type JsonValue<Ext = never> = string | number | boolean | null | JsonObject<Ext> | JsonArray<Ext> | Ext;

// @public (undocumented)
export interface JustSuccessPersistResult {
    // (undocumented)
    afterPersistError?: any;
    // (undocumented)
    persistedEntityIds: EntityId[];
    // (undocumented)
    type: 'justSuccess';
}

// @public (undocumented)
export const LeafFieldDefaults: {
    readonly isNonbearing: false;
};

// @public (undocumented)
export type Limit = number;

// @public (undocumented)
export class LocalizedBindingError extends BindingError {
    constructor(message: string, markerPath: MeaningfulMarker[]);
    // (undocumented)
    readonly markerPath: MeaningfulMarker[];
    // (undocumented)
    nestedIn(wrapper: EntitySubTreeMarker | EntityListSubTreeMarker | HasOneRelationMarker | HasManyRelationMarker): LocalizedBindingError;
}

// @public (undocumented)
export class MarkerComparator {
    // (undocumented)
    static assertEntityMarkersSubsetOf(candidate: EntityFieldMarkersContainer, superset: EntityFieldMarkersContainer): void;
    // (undocumented)
    static isSubTreeSubsetOf(candidate: EntitySubTreeMarker | EntityListSubTreeMarker, superset: EntitySubTreeMarker | EntityListSubTreeMarker): boolean;
}

// @public (undocumented)
export class MarkerFactory {
    // (undocumented)
    static createEntityFieldMarkersContainer(marker: EntityFieldMarker | undefined): EntityFieldMarkersContainer;
    // (undocumented)
    static createEntityFieldsWithHoistablesMarker(fields: EntityFieldMarkersContainer | EntityFieldsWithHoistablesMarker, environment: Environment): EntityFieldsWithHoistablesMarker;
    // (undocumented)
    static createEntityListSubTreeMarker(entityList: SugaredQualifiedEntityList, fields: EntityFieldMarkersContainer | EntityFieldsWithHoistablesMarker, environment: Environment): EntityFieldsWithHoistablesMarker;
    // (undocumented)
    static createEntitySubTreeMarker(entity: SugaredQualifiedSingleEntity, fields: EntityFieldMarkersContainer | EntityFieldsWithHoistablesMarker, environment: Environment): EntityFieldsWithHoistablesMarker;
    // (undocumented)
    static createFieldMarker(field: SugaredRelativeSingleField, environment: Environment): EntityFieldMarkersContainer;
    // (undocumented)
    static createParentEntityMarker(parentEntity: SugaredParentEntityParameters, fields: EntityFieldMarkersContainer | EntityFieldsWithHoistablesMarker, environment: Environment): EntityFieldsWithHoistablesMarker;
    // (undocumented)
    static createRelativeEntityListFields(field: SugaredRelativeEntityList, environment: Environment, fields: EntityFieldsWithHoistablesMarker | EntityFieldMarkersContainer): EntityFieldsWithHoistablesMarker | EntityFieldMarkersContainer;
    // (undocumented)
    static createRelativeSingleEntityFields(field: SugaredRelativeSingleEntity, environment: Environment, fields: EntityFieldsWithHoistablesMarker | EntityFieldMarkersContainer): EntityFieldsWithHoistablesMarker | EntityFieldMarkersContainer;
    // (undocumented)
    static createUnconstrainedEntityListSubTreeMarker(entityList: SugaredUnconstrainedQualifiedEntityList, fields: EntityFieldMarkersContainer | EntityFieldsWithHoistablesMarker, environment: Environment): EntityFieldsWithHoistablesMarker;
    // (undocumented)
    static createUnconstrainedEntitySubTreeMarker(entity: SugaredUnconstrainedQualifiedSingleEntity, fields: EntityFieldMarkersContainer | EntityFieldsWithHoistablesMarker, environment: Environment): EntityFieldsWithHoistablesMarker;
}

// @public (undocumented)
export class MarkerMerger {
    // (undocumented)
    static mergeEntityFieldPlaceholders(original: EntityFieldPlaceholders, fresh: EntityFieldPlaceholders): EntityFieldPlaceholders;
    // (undocumented)
    static mergeEntityFields(original: SubTreeMarkers, fresh: SubTreeMarkers): SubTreeMarkers;
    // (undocumented)
    static mergeEntityFields(original: EntityFieldMarkers, fresh: EntityFieldMarkers): EntityFieldMarkers;
    // (undocumented)
    static mergeEntityFieldsContainers(original: EntityFieldMarkersContainer, fresh: EntityFieldMarkersContainer): EntityFieldMarkersContainer;
    // (undocumented)
    static mergeEntityListSubTreeMarkers(original: EntityListSubTreeMarker, fresh: EntityListSubTreeMarker): EntityListSubTreeMarker;
    // (undocumented)
    static mergeEntitySubTreeMarkers(original: EntitySubTreeMarker, fresh: EntitySubTreeMarker): EntitySubTreeMarker;
    // (undocumented)
    static mergeEnvironments(original: Environment, fresh: Environment): Environment;
    // (undocumented)
    static mergeFieldMarkers(original: FieldMarker, fresh: FieldMarker): FieldMarker;
    // (undocumented)
    static mergeHasManyRelationMarkers(original: HasManyRelationMarker, fresh: HasManyRelationMarker): HasManyRelationMarker;
    // (undocumented)
    static mergeHasOneRelationMarkers(original: HasOneRelationMarker, fresh: HasOneRelationMarker): HasOneRelationMarker;
    // (undocumented)
    static mergeInSystemFields(original: EntityFieldMarkersContainer | undefined): EntityFieldMarkersContainer;
    // (undocumented)
    static mergeMarkers(original: MeaningfulMarker, fresh: MeaningfulMarker): MeaningfulMarker;
    // (undocumented)
    static mergeMarkerTreeRoots(original: MarkerTreeRoot, fresh: MarkerTreeRoot): MarkerTreeRoot;
    // (undocumented)
    static mergeSubTreeMarkers(original: SubTreeMarkers | undefined, fresh: SubTreeMarkers | undefined): SubTreeMarkers | undefined;
    // (undocumented)
    static mergeSubTreePlaceholdersByAliases(original: ReadonlyMap<Alias, PlaceholderName>, fresh: ReadonlyMap<Alias, PlaceholderName>): Map<string, string>;
}

// @public (undocumented)
export class MarkerTreeRoot {
    constructor(subTrees: SubTreeMarkers, placeholdersByAliases: ReadonlyMap<Alias, PlaceholderName>);
    // (undocumented)
    readonly placeholdersByAliases: ReadonlyMap<Alias, PlaceholderName>;
    // (undocumented)
    readonly subTrees: SubTreeMarkers;
}

// @public (undocumented)
export type MeaningfulMarker = FieldMarker | HasOneRelationMarker | HasManyRelationMarker | EntityListSubTreeMarker | EntitySubTreeMarker;

// @public (undocumented)
export const NIL_UUID = "00000000-0000-0000-0000-000000000000";

// @public (undocumented)
export interface NothingToPersistPersistResult {
    // (undocumented)
    type: 'nothingToPersist';
}

// @public (undocumented)
export type Offset = number;

// @public (undocumented)
export type OptionallyVariableFieldValue = FieldValue | VariableFieldValue;

// @public (undocumented)
export type OrderBy = Input.OrderBy<`${Input.OrderDirection}`>[];

// @public (undocumented)
export interface OwningRelation extends BaseRelation {
    // (undocumented)
    inversedBy: FieldName | null;
    // (undocumented)
    ownedBy?: never;
    // (undocumented)
    side: 'owning';
}

// @public (undocumented)
export interface ParentEntityParameters {
    // (undocumented)
    eventListeners: EntityEventListenerStore | undefined;
}

// @public
export class Parser extends EmbeddedActionsParser {
    // (undocumented)
    static parseQueryLanguageExpression<E extends Parser.EntryPoint>(input: string, entry: E, environment: Environment): Parser.ParserResult[E];
}

// @public (undocumented)
export namespace Parser {
    // (undocumented)
    export namespace AST {
        // (undocumented)
        export type ColumnValue = Input.ColumnValue;
        // (undocumented)
        export type Condition = Input.Condition<ColumnValue>;
        // (undocumented)
        export type ConditionOperator = keyof Pick<Condition, 'eq' | 'notEq' | 'lt' | 'lte' | 'gt' | 'gte'>;
        // (undocumented)
        export type FieldWhere = Input.FieldWhere<Condition>;
    }
    // (undocumented)
    export type EntryPoint = keyof ParserResult;
    // (undocumented)
    export interface ParserResult {
        // (undocumented)
        columnValue: AST.ColumnValue;
        // (undocumented)
        filter: Filter;
        // (undocumented)
        orderBy: OrderBy;
        // Warning: (ae-forgotten-export) The symbol "ParsedQualifiedEntityList" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        qualifiedEntityList: ParsedQualifiedEntityList;
        // Warning: (ae-forgotten-export) The symbol "ParsedQualifiedFieldList" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        qualifiedFieldList: ParsedQualifiedFieldList;
        // Warning: (ae-forgotten-export) The symbol "ParsedQualifiedSingleEntity" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        qualifiedSingleEntity: ParsedQualifiedSingleEntity;
        // Warning: (ae-forgotten-export) The symbol "ParsedRelativeEntityList" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        relativeEntityList: ParsedRelativeEntityList;
        // Warning: (ae-forgotten-export) The symbol "ParsedRelativeSingleEntity" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        relativeSingleEntity: ParsedRelativeSingleEntity;
        // Warning: (ae-forgotten-export) The symbol "ParsedRelativeSingleField" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        relativeSingleField: ParsedRelativeSingleField;
        // Warning: (ae-forgotten-export) The symbol "ParsedTaggedMap" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        taggedMap: ParsedTaggedMap;
        // Warning: (ae-forgotten-export) The symbol "ParsedUnconstrainedQualifiedEntityList" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        unconstrainedQualifiedEntityList: ParsedUnconstrainedQualifiedEntityList;
        // Warning: (ae-forgotten-export) The symbol "ParsedUnconstrainedQualifiedSingleEntity" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        unconstrainedQualifiedSingleEntity: ParsedUnconstrainedQualifiedSingleEntity;
        // (undocumented)
        uniqueWhere: UniqueWhere;
    }
}

// @public (undocumented)
export type Persist = (options?: PersistOptions) => Promise<SuccessfulPersistResult>;

// @public (undocumented)
export interface PersistErrorOptions extends AsyncBatchUpdatesOptions {
}

// @public (undocumented)
export interface PersistOptions {
    // (undocumented)
    onPersistError?: (options: PersistErrorOptions) => void | Promise<void>;
    // (undocumented)
    onPersistSuccess?: (options: PersistSuccessOptions) => void | Promise<void>;
    // (undocumented)
    signal?: AbortSignal;
}

// @public (undocumented)
export interface PersistSuccessOptions extends AsyncBatchUpdatesOptions {
    // (undocumented)
    successType: 'justSuccess' | 'nothingToPersist';
}

// @public (undocumented)
export class PlaceholderGenerator {
    // (undocumented)
    static getEntityListSubTreePlaceholder(subTreeParameters: QualifiedEntityList | UnconstrainedQualifiedEntityList, environment: Environment): string;
    // (undocumented)
    static getEntitySubTreePlaceholder(subTreeParameters: QualifiedSingleEntity | UnconstrainedQualifiedSingleEntity, environment: Environment): string;
    // (undocumented)
    static getFieldPlaceholder(fieldName: FieldName): string;
    // (undocumented)
    static getHasManyRelationPlaceholder(relation: HasManyRelation): string;
    // (undocumented)
    static getHasOneRelationPlaceholder(relation: HasOneRelation): string;
}

// @public (undocumented)
export type PlaceholderName = string;

// @public (undocumented)
export class PlaceholderParametersGenerator {
    // (undocumented)
    static createEntityListSubTreeParameters(parameters: QualifiedEntityList | UnconstrainedQualifiedEntityList, environment: Environment): any;
    // (undocumented)
    static createEntitySubTreeParameters(parameters: QualifiedSingleEntity | UnconstrainedQualifiedSingleEntity, environment: Environment): any;
    // (undocumented)
    static createHasManyRelationParameters(relation: HasManyRelation): any;
    // (undocumented)
    static createHasOneRelationParameters(relation: HasOneRelation): any;
}

// @public (undocumented)
export const PRIMARY_KEY_NAME = "id";

// @public (undocumented)
export interface QualifiedEntityList {
    // (undocumented)
    alias: Set<Alias> | undefined;
    // (undocumented)
    childEventListeners: EntityEventListenerStore | undefined;
    // (undocumented)
    entityName: EntityName;
    // (undocumented)
    eventListeners: EntityListEventListenerStore | undefined;
    // (undocumented)
    expectedMutation: ExpectedQualifiedEntityMutation;
    // (undocumented)
    filter: Filter | undefined;
    // (undocumented)
    hasOneRelationPath: HasOneRelation[];
    // (undocumented)
    initialEntityCount: number;
    // (undocumented)
    isCreating: false;
    // (undocumented)
    isNonbearing: boolean;
    // (undocumented)
    limit: Limit | undefined;
    // (undocumented)
    offset: Offset | undefined;
    // (undocumented)
    orderBy: OrderBy | undefined;
    // (undocumented)
    setOnCreate: SetOnCreate;
}

// @public (undocumented)
export const QualifiedEntityParametersDefaults: {
    readonly expectedMutation: "anyMutation";
};

// @public (undocumented)
export type QualifiedFieldList = {
    entityName: EntityName;
    field: FieldName;
    hasOneRelationPath: HasOneRelation[];
    orderBy: OrderBy | undefined;
    offset: Offset | undefined;
    limit: Limit | undefined;
    filter: Filter | undefined;
    alias: Set<Alias> | undefined;
    defaultValue: FieldValue | undefined;
    expectedMutation: ExpectedQualifiedEntityMutation;
    initialEntityCount: number;
    isNonbearing: boolean;
    eventListeners: FieldEventListenerStore | undefined;
};

// @public (undocumented)
export interface QualifiedSingleEntity {
    // (undocumented)
    alias: Set<Alias> | undefined;
    // (undocumented)
    entityName: EntityName;
    // (undocumented)
    eventListeners: EntityEventListenerStore | undefined;
    // (undocumented)
    expectedMutation: ExpectedQualifiedEntityMutation;
    // (undocumented)
    filter: Filter | undefined;
    // (undocumented)
    hasOneRelationPath: HasOneRelation[];
    // (undocumented)
    isCreating: false;
    // (undocumented)
    isNonbearing: boolean;
    // (undocumented)
    setOnCreate: SetOnCreate;
    // (undocumented)
    where: UniqueWhere;
}

// @public (undocumented)
export class QueryLanguage {
    // (undocumented)
    static desugarEventListener<F extends Function>(listener: F | Set<F>): Set<F>;
    // (undocumented)
    static desugarEventListener<F extends Function>(listener: F | Set<F> | undefined): Set<F> | undefined;
    // (undocumented)
    static desugarFilter: (input: string | Filter, environment: Environment) => Filter;
    // (undocumented)
    static desugarOrderBy: (input: string | OrderBy, environment: Environment) => OrderBy;
    // (undocumented)
    static desugarParentEntityParameters(parentEntity: SugaredParentEntityParameters, environment: Environment): ParentEntityParameters;
    // (undocumented)
    static desugarQualifiedEntityList({ entities, ...unsugarableEntityList }: SugaredQualifiedEntityList, environment: Environment): QualifiedEntityList;
    // (undocumented)
    static desugarQualifiedFieldList({ fields, ...unsugarableFieldList }: SugaredQualifiedFieldList, environment: Environment): QualifiedFieldList;
    // (undocumented)
    static desugarQualifiedSingleEntity({ entity, ...unsugarableSingleEntity }: SugaredQualifiedSingleEntity, environment: Environment): QualifiedSingleEntity;
    // (undocumented)
    static desugarRelativeEntityList(sugaredRelativeEntityList: string | SugaredRelativeEntityList, environment: Environment): RelativeEntityList;
    // (undocumented)
    static desugarRelativeSingleEntity(sugaredRelativeSingleEntity: string | SugaredRelativeSingleEntity, environment: Environment): RelativeSingleEntity;
    // (undocumented)
    static desugarRelativeSingleField(sugaredRelativeSingleField: string | SugaredRelativeSingleField, environment: Environment): RelativeSingleField;
    // (undocumented)
    static desugarSetOnCreate(setOnCreate: SugaredSetOnCreate, environment: Environment): UniqueWhere;
    // (undocumented)
    static desugarTaggedMap: (input: string | ParsedTaggedMap, environment: Environment) => ParsedTaggedMap;
    // (undocumented)
    static desugarUnconstrainedQualifiedEntityList({ entities, ...unsugarableEntityList }: SugaredUnconstrainedQualifiedEntityList, environment: Environment): UnconstrainedQualifiedEntityList;
    // (undocumented)
    static desugarUnconstrainedQualifiedSingleEntity({ entity, ...unsugarableSingleEntity }: SugaredUnconstrainedQualifiedSingleEntity, environment: Environment): UnconstrainedQualifiedSingleEntity;
    // (undocumented)
    static desugarUniqueWhere: (input: string | UniqueWhere, environment: Environment) => UniqueWhere;
}

// @public (undocumented)
export class QueryLanguageError extends Error {
}

// @public (undocumented)
export interface QueryRequestResponse {
    // (undocumented)
    data: ReceivedDataTree;
    // (undocumented)
    errors?: {
        message: string;
        path?: string[];
    }[];
}

// @public (undocumented)
export interface RawSchema {
    // Warning: (ae-forgotten-export) The symbol "RawSchemaEntity" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    entities: RawSchemaEntity[];
    // Warning: (ae-forgotten-export) The symbol "RawSchemaEnum" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    enums: RawSchemaEnum[];
}

// @public (undocumented)
export type ReceivedData = ReceivedEntityData | ReceivedEntityData[];

// @public (undocumented)
export interface ReceivedDataTree {
    // (undocumented)
    [treeId: string]: ReceivedData | null;
}

// @public (undocumented)
export type ReceivedEntityData = {
    __typename: string;
    _meta?: {
        [fieldName: string]: {
            readable?: boolean;
            updatable?: boolean;
        };
    };
    id: EntityId;
} & {
    [fieldName: string]: ReceivedFieldData;
};

// @public (undocumented)
export type ReceivedFieldData = FieldValue | ReceivedEntityData | Array<ReceivedEntityData>;

// @public (undocumented)
export const RelationDefaults: {
    readonly expectedMutation: "anyMutation";
};

// @public (undocumented)
export interface RelativeEntityList {
    // (undocumented)
    hasManyRelation: HasManyRelation;
    // (undocumented)
    hasOneRelationPath: HasOneRelation[];
}

// @public (undocumented)
export interface RelativeSingleEntity {
    // (undocumented)
    hasOneRelationPath: HasOneRelation[];
}

// @public (undocumented)
export type RelativeSingleField = {
    field: FieldName;
    hasOneRelationPath: HasOneRelation[];
    defaultValue: FieldValue | undefined;
    isNonbearing: boolean;
    meta: FieldMeta;
    eventListeners: FieldEventListenerStore | undefined;
};

// @public (undocumented)
export type RemovalType = 'disconnect' | 'delete';

// @public (undocumented)
export type RuntimeId = ServerId | ClientGeneratedUuid | UnpersistedEntityDummyId;

// @public (undocumented)
export interface RuntimeIdSpec {
    // (undocumented)
    existsOnServer: boolean;
    // (undocumented)
    uniqueValue: UniqueEntityId;
    // (undocumented)
    value: EntityId;
}

// @public (undocumented)
export type Scalar = string | number | boolean | null;

// @public (undocumented)
export class Schema {
    constructor(store: SchemaStore);
    // (undocumented)
    getEntity(entityName: EntityName): SchemaEntity;
    // (undocumented)
    getEntityColumn(entityName: EntityName, fieldName: FieldName): SchemaColumn;
    // (undocumented)
    getEntityField(entityName: EntityName, fieldName: FieldName): SchemaField;
    // (undocumented)
    getEntityFieldOrUndefined(entityName: EntityName, fieldName: FieldName): SchemaField | undefined;
    // (undocumented)
    getEntityNames(): string[];
    // (undocumented)
    getEntityOrUndefined(entityName: EntityName): SchemaEntity | undefined;
    // (undocumented)
    getEntityRelation(entityName: EntityName, fieldName: FieldName): SchemaRelation;
    // (undocumented)
    getEnumNames(): string[];
    // (undocumented)
    getEnumValues(enumName: SchemaEnumName): string[];
}

// @public (undocumented)
export interface SchemaColumn {
    // (undocumented)
    __typename: '_Column';
    // (undocumented)
    defaultValue: any;
    // (undocumented)
    deprecationReason: string | null;
    // (undocumented)
    description: string | null;
    // (undocumented)
    enumName: SchemaEnumName | null;
    // (undocumented)
    name: FieldName;
    // (undocumented)
    nullable: boolean;
    // (undocumented)
    type: SchemaColumnType;
}

// @public (undocumented)
export type SchemaColumnType = SchemaKnownColumnType | string;

// @public (undocumented)
export type SchemaEntities = Map<EntityName, SchemaEntity>;

// @public (undocumented)
export interface SchemaEntity {
    // (undocumented)
    customPrimaryAllowed: boolean;
    // (undocumented)
    fields: SchemaFields;
    // (undocumented)
    name: EntityName;
    // (undocumented)
    unique: SchemaUniqueConstraint[];
}

// @public (undocumented)
export type SchemaEnumName = string;

// @public (undocumented)
export type SchemaEnums = Map<SchemaEnumName, SchemaEnumValues>;

// @public (undocumented)
export type SchemaEnumValues = Set<string>;

// @public (undocumented)
export type SchemaField = SchemaRelation | SchemaColumn;

// @public (undocumented)
export type SchemaFields = Map<FieldName, SchemaField>;

// @public (undocumented)
export type SchemaKnownColumnType = 'Bool' | 'Date' | 'DateTime' | 'Double' | 'Enum' | 'Integer' | 'String' | 'Uuid' | 'Time';

// @public (undocumented)
export class SchemaLoader {
    // (undocumented)
    static loadSchema(client: GraphQlClient, options?: GraphQlClientRequestOptions): Promise<Schema>;
}

// @public (undocumented)
export class SchemaPreprocessor {
    // (undocumented)
    static processRawSchema(rawSchema: RawSchema): SchemaStore;
}

// @public (undocumented)
export type SchemaRelation = OwningRelation | InverseRelation;

// @public (undocumented)
export interface SchemaRelationOrderBy {
    // (undocumented)
    direction: 'asc' | 'desc';
    // (undocumented)
    path: string[];
}

// @public (undocumented)
export interface SchemaStore {
    // (undocumented)
    entities: SchemaEntities;
    // (undocumented)
    enums: SchemaEnums;
}

// @public (undocumented)
export interface SchemaUniqueConstraint {
    // (undocumented)
    fields: Set<FieldName>;
}

// @public (undocumented)
export class ServerId implements RuntimeIdSpec {
    constructor(value: EntityId, entityName: string);
    // (undocumented)
    readonly entityName: string;
    // (undocumented)
    get existsOnServer(): true;
    // (undocumented)
    static formatUniqueValue(id: EntityId, entityName: string): UniqueEntityId;
    // (undocumented)
    get uniqueValue(): UniqueEntityId;
    // (undocumented)
    readonly value: EntityId;
}

// @public (undocumented)
export type SetOnCreate = UniqueWhere | undefined;

// @public (undocumented)
export type SubTreeMarkers = ReadonlyMap<PlaceholderName, EntitySubTreeMarker | EntityListSubTreeMarker>;

// @public (undocumented)
export type SuccessfulPersistResult = NothingToPersistPersistResult | JustSuccessPersistResult;

// @public (undocumented)
export interface SugarableHasManyRelation {
    // (undocumented)
    field: FieldName;
    // (undocumented)
    filter?: SugaredFilter;
}

// @public (undocumented)
export interface SugarableHasOneRelation {
    // (undocumented)
    field: FieldName;
    // (undocumented)
    filter?: SugaredFilter;
    // (undocumented)
    reducedBy?: SugaredUniqueWhere;
}

// @public (undocumented)
export type SugaredFilter = Filter | string;

// @public (undocumented)
export type SugaredOrderBy = OrderBy | string;

// @public (undocumented)
export interface SugaredParentEntityParameters extends UnsugarableSingleEntityEventListeners {
}

// @public (undocumented)
export interface SugaredQualifiedEntityList extends UnsugarableEntityListEventListeners {
    // (undocumented)
    alias?: Alias | Set<Alias>;
    // (undocumented)
    entities: string | {
        filter?: SugaredFilter;
        hasOneRelationPath?: SugarableHasOneRelation[] | SugarableHasOneRelation;
        entityName: EntityName;
    };
    // (undocumented)
    expectedMutation?: ExpectedQualifiedEntityMutation;
    // (undocumented)
    initialEntityCount?: number;
    // (undocumented)
    isCreating?: false;
    // (undocumented)
    isNonbearing?: boolean;
    // (undocumented)
    limit?: Limit;
    // (undocumented)
    offset?: Offset;
    // (undocumented)
    orderBy?: SugaredOrderBy;
    // (undocumented)
    setOnCreate?: SugaredSetOnCreate;
}

// @public (undocumented)
export interface SugaredQualifiedFieldList extends UnsugarableFieldEventListeners {
    // (undocumented)
    alias?: Alias | Set<Alias>;
    // (undocumented)
    defaultValue?: OptionallyVariableFieldValue;
    // (undocumented)
    expectedMutation?: ExpectedQualifiedEntityMutation;
    // (undocumented)
    fields: string | {
        filter?: SugaredFilter;
        field: FieldName;
        entityName: EntityName;
        hasOneRelationPath?: SugarableHasOneRelation[] | SugarableHasOneRelation;
    };
    // (undocumented)
    initialEntityCount?: number;
    // (undocumented)
    isNonbearing?: boolean;
    // (undocumented)
    limit?: Limit;
    // (undocumented)
    offset?: Offset;
    // (undocumented)
    orderBy?: SugaredOrderBy;
}

// @public (undocumented)
export interface SugaredQualifiedSingleEntity extends UnsugarableSingleEntityEventListeners {
    // (undocumented)
    alias?: Alias | Set<Alias>;
    // (undocumented)
    entity: string | {
        where: SugaredUniqueWhere;
        filter?: SugaredFilter;
        hasOneRelationPath?: SugarableHasOneRelation[] | SugarableHasOneRelation;
        entityName: EntityName;
    };
    // (undocumented)
    expectedMutation?: ExpectedQualifiedEntityMutation;
    // (undocumented)
    isCreating?: false;
    // (undocumented)
    isNonbearing?: boolean;
    // (undocumented)
    setOnCreate?: SugaredSetOnCreate;
}

// @public (undocumented)
export interface SugaredRelativeEntityList extends UnsugarableEntityListEventListeners {
    // (undocumented)
    expectedMutation?: ExpectedRelationMutation;
    // (undocumented)
    field: string | {
        hasOneRelationPath?: SugarableHasOneRelation[] | SugarableHasOneRelation;
        hasManyRelation: SugarableHasManyRelation;
    };
    // (undocumented)
    initialEntityCount?: number;
    // (undocumented)
    isNonbearing?: boolean;
    // (undocumented)
    limit?: Limit;
    // (undocumented)
    offset?: Offset;
    // (undocumented)
    orderBy?: SugaredOrderBy;
    // (undocumented)
    setOnCreate?: SugaredSetOnCreate;
    // (undocumented)
    withMeta?: FieldMeta;
}

// @public (undocumented)
export interface SugaredRelativeSingleEntity extends UnsugarableSingleEntityEventListeners {
    // (undocumented)
    expectedMutation?: ExpectedRelationMutation;
    // (undocumented)
    field: string | SugarableHasOneRelation[] | SugarableHasOneRelation;
    // (undocumented)
    isNonbearing?: boolean;
    // (undocumented)
    setOnCreate?: SugaredSetOnCreate;
    // (undocumented)
    withMeta?: FieldMeta;
}

// @public (undocumented)
export interface SugaredRelativeSingleField extends UnsugarableFieldEventListeners {
    // (undocumented)
    defaultValue?: OptionallyVariableFieldValue;
    field: string | {
        field: FieldName;
        hasOneRelationPath?: SugarableHasOneRelation[] | SugarableHasOneRelation;
    };
    // (undocumented)
    isNonbearing?: boolean;
    // (undocumented)
    withMeta?: FieldMeta;
}

// @public (undocumented)
export type SugaredSetOnCreate = SugaredUniqueWhere | SugaredUniqueWhere[] | Exclude<SetOnCreate, undefined>;

// @public (undocumented)
export interface SugaredUnconstrainedQualifiedEntityList extends UnsugarableEntityListEventListeners {
    // (undocumented)
    alias?: Alias | Set<Alias>;
    // (undocumented)
    entities: string | {
        hasOneRelationPath?: SugarableHasOneRelation[] | SugarableHasOneRelation;
        entityName: EntityName;
    };
    // (undocumented)
    expectedMutation?: ExpectedQualifiedEntityMutation;
    // (undocumented)
    initialEntityCount?: number;
    // (undocumented)
    isCreating: true;
    // (undocumented)
    isNonbearing?: boolean;
    // (undocumented)
    isUnpersisted?: boolean;
    // (undocumented)
    setOnCreate?: SugaredSetOnCreate;
}

// @public (undocumented)
export interface SugaredUnconstrainedQualifiedSingleEntity extends UnsugarableSingleEntityEventListeners {
    // (undocumented)
    alias?: Alias | Set<Alias>;
    // (undocumented)
    entity: string | {
        entityName: EntityName;
        hasOneRelationPath?: SugarableHasOneRelation[] | SugarableHasOneRelation;
    };
    // (undocumented)
    expectedMutation?: ExpectedQualifiedEntityMutation;
    // (undocumented)
    isCreating: true;
    // (undocumented)
    isNonbearing?: boolean;
    // (undocumented)
    isUnpersisted?: boolean;
    // (undocumented)
    setOnCreate?: SugaredSetOnCreate;
}

// @public (undocumented)
export type SugaredUniqueWhere = UniqueWhere | string;

// @public (undocumented)
export const throwBindingError: (message: string) => never;

// @public (undocumented)
export const tokenList: TokenType[];

// @public (undocumented)
export namespace TokenRegExps {
    const // (undocumented)
    entityIdentifier: RegExp;
    const // (undocumented)
    identifier: RegExp;
    const // (undocumented)
    dotSeparatedIdentifier: RegExp;
}

// @public (undocumented)
export const tokens: {
    WhiteSpace: TokenType;
    EntityIdentifier: TokenType;
    Identifier: TokenType;
    DollarSign: TokenType;
    Dot: TokenType;
    Comma: TokenType;
    Colon: TokenType;
    Slash: TokenType;
    NumberLiteral: TokenType;
    StringLiteral: TokenType;
    LeftParenthesis: TokenType;
    RightParenthesis: TokenType;
    LeftBracket: TokenType;
    RightBracket: TokenType;
    NotEquals: TokenType;
    True: TokenType;
    False: TokenType;
    Null: TokenType;
    Equals: TokenType;
    Not: TokenType;
    And: TokenType;
    Or: TokenType;
    LowerEqual: TokenType;
    GreaterEqual: TokenType;
    LowerThan: TokenType;
    GreaterThan: TokenType;
};

// @public (undocumented)
export class TreeNodeEnvironmentFactory {
    // (undocumented)
    static createEnvironmentForEntity(environment: Environment, sugaredRelativeSingleEntity: SugaredRelativeSingleEntity): Environment<Environment.AnyNode | undefined>;
    // (undocumented)
    static createEnvironmentForEntityList(environment: Environment, sugaredRelativeEntityList: SugaredRelativeEntityList): Environment;
    // (undocumented)
    static createEnvironmentForEntityListSubtree(environment: Environment, sugaredEntityList: SugaredQualifiedEntityList | SugaredUnconstrainedQualifiedEntityList): Environment;
    // (undocumented)
    static createEnvironmentForEntitySubtree(environment: Environment, sugaredEntityList: SugaredQualifiedSingleEntity | SugaredUnconstrainedQualifiedSingleEntity): Environment;
    // (undocumented)
    static createEnvironmentForField(environment: Environment, sugaredRelativeSingleField: SugaredRelativeSingleField): Environment<{
        type: "column";
        entity: SchemaEntity;
        field: SchemaColumn;
    }>;
}

// @public (undocumented)
export class TreeNodeUtils {
    // (undocumented)
    static describeLocation(environment: Environment): string;
    // (undocumented)
    static recommendAlternative(original: string, possibleAlternatives: Iterable<string>): string | undefined;
    // (undocumented)
    static resolveColumn(environment: Environment, fieldName: string): SchemaColumn;
    // (undocumented)
    static resolveEntity(schema: Schema, entityName: string, type: 'entity' | 'entity list'): SchemaEntity;
    // (undocumented)
    static resolveHasManyRelation(environment: Environment, field: string): SchemaRelation;
    // (undocumented)
    static resolveHasOneRelation(environment: Environment, field: string, isReduced: boolean): SchemaRelation;
}

// @public (undocumented)
export class TreeParameterMerger {
    // (undocumented)
    static mergeEntityListSubTreeParametersWithSamePlaceholders(original: QualifiedEntityList | UnconstrainedQualifiedEntityList, fresh: QualifiedEntityList | UnconstrainedQualifiedEntityList): QualifiedEntityList | UnconstrainedQualifiedEntityList;
    // (undocumented)
    static mergeEntitySubTreeParametersWithSamePlaceholders(original: QualifiedSingleEntity | UnconstrainedQualifiedSingleEntity, fresh: QualifiedSingleEntity | UnconstrainedQualifiedSingleEntity): QualifiedSingleEntity | UnconstrainedQualifiedSingleEntity;
    // (undocumented)
    static mergeHasManyRelationsWithSamePlaceholders(original: HasManyRelation, fresh: HasManyRelation): HasManyRelation;
    // (undocumented)
    static mergeHasOneRelationsWithSamePlaceholders(original: HasOneRelation, fresh: HasOneRelation): HasOneRelation;
    // (undocumented)
    static mergeInParentEntity<Original extends Record<Key, EntityEventListenerStore | undefined>, Key extends keyof Original>(original: Original, key: Key, parentEntity: ParentEntityParameters | undefined): Original;
    // (undocumented)
    static mergeParentEntityParameters(original: ParentEntityParameters | undefined, fresh: ParentEntityParameters | undefined): ParentEntityParameters | undefined;
    // (undocumented)
    static mergeSetOnCreate(original: SetOnCreate, fresh: SetOnCreate): SetOnCreate;
    // (undocumented)
    static mergeSingleField(original: Omit<RelativeSingleField, 'hasOneRelationPath'>, fresh: Omit<RelativeSingleField, 'hasOneRelationPath'>): Omit<RelativeSingleField, 'hasOneRelationPath'>;
}

// @public (undocumented)
export class TreeRootAccessor<Node> {
    constructor(hasUnpersistedChanges: boolean, isMutating: boolean, bindingOperations: BindingOperations<Node>);
    // (undocumented)
    readonly bindingOperations: BindingOperations<Node>;
    // (undocumented)
    readonly hasUnpersistedChanges: boolean;
    // (undocumented)
    readonly isMutating: boolean;
}

// @public (undocumented)
export type TreeRootId = string;

// @public (undocumented)
export const TYPENAME_KEY_NAME = "__typename";

// @public (undocumented)
export interface UnconstrainedQualifiedEntityList {
    // (undocumented)
    alias: Set<Alias> | undefined;
    // (undocumented)
    childEventListeners: EntityEventListenerStore | undefined;
    // (undocumented)
    entityName: EntityName;
    // (undocumented)
    eventListeners: EntityListEventListenerStore | undefined;
    // (undocumented)
    expectedMutation: ExpectedQualifiedEntityMutation;
    // (undocumented)
    hasOneRelationPath: HasOneRelation[];
    // (undocumented)
    initialEntityCount: number;
    // (undocumented)
    isCreating: true;
    // (undocumented)
    isNonbearing: boolean;
    // (undocumented)
    isUnpersisted: boolean;
    // (undocumented)
    setOnCreate: SetOnCreate;
}

// @public (undocumented)
export interface UnconstrainedQualifiedSingleEntity {
    // (undocumented)
    alias: Set<Alias> | undefined;
    // (undocumented)
    entityName: EntityName;
    // (undocumented)
    eventListeners: EntityEventListenerStore | undefined;
    // (undocumented)
    expectedMutation: ExpectedQualifiedEntityMutation;
    // (undocumented)
    hasOneRelationPath: HasOneRelation[];
    // (undocumented)
    isCreating: true;
    // (undocumented)
    isNonbearing: boolean;
    // (undocumented)
    isUnpersisted: boolean;
    // (undocumented)
    setOnCreate: SetOnCreate;
}

// @public (undocumented)
export type UniqueEntityId = string & {
    __type: 'UniqueEntityId';
};

// @public (undocumented)
export type UniqueWhere<T = never> = Input.UniqueWhere<T>;

// @public (undocumented)
export class UnpersistedEntityDummyId implements RuntimeIdSpec {
    constructor();
    // (undocumented)
    get existsOnServer(): false;
    // (undocumented)
    static matchesDummyId(candidate: EntityId): boolean;
    // (undocumented)
    get uniqueValue(): UniqueEntityId;
    // (undocumented)
    readonly value: string;
}

// @public (undocumented)
export type UnsugarableEntityListEventListeners = {
    onBeforePersist?: EntityListAccessor.BeforePersistHandler | Set<EntityListAccessor.BeforePersistHandler>;
    onBeforeUpdate?: EntityListAccessor.BatchUpdatesHandler | Set<EntityListAccessor.BatchUpdatesHandler>;
    onPersistError?: EntityListAccessor.PersistErrorHandler | Set<EntityListAccessor.PersistErrorHandler>;
    onPersistSuccess?: EntityListAccessor.PersistSuccessHandler | Set<EntityListAccessor.PersistSuccessHandler>;
    onUpdate?: EntityListAccessor.UpdateListener | Set<EntityListAccessor.UpdateListener>;
    onInitialize?: EntityListAccessor.BatchUpdatesHandler | Set<EntityListAccessor.BatchUpdatesHandler>;
    onChildBeforeUpdate?: EntityAccessor.BatchUpdatesHandler | Set<EntityAccessor.BatchUpdatesHandler>;
    onChildInitialize?: EntityAccessor.BatchUpdatesHandler | Set<EntityAccessor.BatchUpdatesHandler>;
    onChildUpdate?: EntityAccessor.UpdateListener | Set<EntityAccessor.UpdateListener>;
};

// @public (undocumented)
export type UnsugarableFieldEventListeners<Persisted extends FieldValue = FieldValue> = {
    onInitialize?: FieldAccessor.InitializeListener<Persisted> | Set<FieldAccessor.InitializeListener<Persisted>>;
    onBeforeUpdate?: FieldAccessor.BeforeUpdateListener<Persisted> | Set<FieldAccessor.BeforeUpdateListener<Persisted>>;
    onUpdate?: FieldAccessor.UpdateListener<Persisted> | Set<FieldAccessor.UpdateListener<Persisted>>;
};

// @public (undocumented)
export type UnsugarableSingleEntityEventListeners = {
    onBeforePersist?: EntityAccessor.BeforePersistHandler | Set<EntityAccessor.BeforePersistHandler>;
    onBeforeUpdate?: EntityAccessor.BatchUpdatesHandler | Set<EntityAccessor.BatchUpdatesHandler>;
    onPersistError?: EntityAccessor.PersistErrorHandler | Set<EntityAccessor.PersistErrorHandler>;
    onPersistSuccess?: EntityAccessor.PersistSuccessHandler | Set<EntityAccessor.PersistSuccessHandler>;
    onUpdate?: EntityAccessor.UpdateListener | Set<EntityAccessor.UpdateListener>;
    onInitialize?: EntityAccessor.BatchUpdatesHandler | Set<EntityAccessor.BatchUpdatesHandler>;
    onConnectionUpdate?: {
        [fieldName: string]: EntityAccessor.UpdateListener | Set<EntityAccessor.UpdateListener>;
    };
};

// @public (undocumented)
export class VariableFieldValue {
    constructor(variableName: string);
    // (undocumented)
    readonly variableName: string;
}

// @public (undocumented)
export class VariableInputTransformer {
    // (undocumented)
    static transformValue(value: OptionallyVariableFieldValue, environment: Environment): FieldValue;
    // (undocumented)
    static transformVariableFieldValue(variableFieldValue: VariableFieldValue, environment: Environment): FieldValue;
}

// @public (undocumented)
export const whereToFilter: (by: Input.UniqueWhere) => Input.Where<Input.Condition<Input.ColumnValue>>;

// @public (undocumented)
export const wrapFilterInHasOnes: (path: HasOneRelation[], filter: Filter) => Filter;

// (No @packageDocumentation comment for this package)

```
