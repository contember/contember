---
title: BlockElement
---

<!-- Edited by human: false -->
<!-- Examples count: 1 -->
<!-- Source examples: 0 -->
<!-- Playground examples: 1 -->
<!-- External examples: 0 -->
<!-- Import examples: 1 -->

# BlockElement

## Overview
`BlockElement` wraps its children in a chosen HTML block element.
Use it inside a Slate editor to isolate complex blocks like images or custom widgets while optionally drawing edit-mode boundaries.

## Styling Guidelines
* All examples use Tailwind CSS.
* No Contember-specific theme classes are required.

## Core Concepts
* `domElement` switches the rendered HTML tag.
* `withBoundaries` adds a subtle outline in edit mode.
* `className` forwards Tailwind utilities to the wrapper.

## Quick Start
```tsx
import { BlockElement } from '~/lib/editor'

export const SimpleBlock = () => (
  <BlockElement withBoundaries className="p-4 border rounded-md">
    <p className="text-sm">Your rich text lives here.</p>
  </BlockElement>
)
```

## Detailed Guide
```tsx
// Render as <li> inside a custom list renderer
<BlockElement domElement="li" className="list-disc ml-6">
  {children}
</BlockElement>
```

```tsx
// Visual cue for a horizontal rule
<BlockElement withBoundaries>
  <span contentEditable={false}>
    <hr className="border-t border-gray-300" />
  </span>
</BlockElement>
```

## Props Reference
| Name | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| domElement | keyof JSX.IntrinsicElements | No | `"div"` | HTML tag used for the wrapper. |
| withBoundaries | boolean | No | `false` | Shows an outline when `true`. |
| className | string | No | `""` | Tailwind classes applied to the wrapper. |

## Examples
### Editable vs Read-Only Rendering
```tsx
<BlockElement
  element={props.element}
  attributes={props.attributes}
  withBoundaries
>
  {isEditable ? (
    wrappedReference
  ) : (
    <>
      {/* Keep reference non-editable in read-only mode */}
      <div
        contentEditable={false}
        data-slate-editor={false}
        style={isFullWidth ? undefined : { display: 'inline-block' }}
      >
        {wrappedReference}
      </div>
      {props.children}
    </>
  )}
</BlockElement>
```
The example shows how you can render different markup based on the editor state while preserving a non-editable reference element.

## Best Practices & Gotchas
* Wrap non-editable UI with `contentEditable={false}` to avoid cursor issues.
* Enable `withBoundaries` only in edit mode to reduce visual noise in read-only views.
* Prefer semantic tags via `domElement` for accessibility (`<ol>`, `<li>`, `<section>`).

## Further Reading
* Slate `useSelected` hook for selection state.
* Contember `InlineElement` for inline rich-text constructs.
* Tailwind spacing and border utilities for consistent visuals.

<!-- End of Generated Documentation -->
