---
title: DefaultBlockRepeater
---

<!-- Edited by human: false -->
<!-- Examples count: 3 -->

# DefaultBlockRepeater

## Overview
`DefaultBlockRepeater` lets you create and manage repeatable content blocks inside a Contember form.
You can edit blocks inline or switch to a dual‑mode that opens a dedicated form for each block.

## Styling Guidelines
* All examples use Tailwind for layout and spacing.
* No special Contember theme classes are required—apply your own Tailwind utilities.

## Core Concepts
* Define a collection of blocks with the `field` (or `entities`) prop.
* Provide a `discriminationField` so Contember knows which block type is stored.
* Use `sortableBy` to enable drag‑and‑drop reordering.
* Wrap each block definition in a `<Block>` element.
* Inline edit = only `children`. Dual‑mode = both `form` and `children`.

## Quick Start
```tsx
import { DefaultBlockRepeater, Block } from '~/lib/block-repeater'

<DefaultBlockRepeater
  field="blocks"
  sortableBy="order"
  discriminationField="type"
>
  <Block name="text" label="Text">
    {/* Inline edit – no separate form view */}
    <InputField field="content" label="Content" />
  </Block>
</DefaultBlockRepeater>
```

## Detailed Guide
_None_

## Props Reference
| Name | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| field | Unknown | No | — | Relation field holding the block list. |
| entities | Unknown | No | — | Alternative to `field` when working with queried entities. |
| sortableBy | Unknown | No | — | Field used for drag‑and‑drop ordering. |
| discriminationField | Unknown | Yes | — | Field storing the block type discriminator. |
| children | ReactNode | Yes | — | One or more `<Block>` elements. |
| *Inherited props* | — | — | — | _None_ |

## Sub-Components / Building Blocks
### Block
Defines a single block type.
Props include `name`, `label`, plus optional `form` and `children` for dual‑mode editing.

### EntityView
Renders entities using a render prop. Commonly used for complex visualisation inside a block.

### StaticRender
Outputs static content (e.g., a colour field) without entering edit mode.

## Examples
### Dual‑mode repeater with four block types
```tsx
import { DefaultBlockRepeater, Block } from '~/lib/block-repeater'

<DefaultBlockRepeater field="blocks" sortableBy="order" discriminationField="type">
  <Block
    name="text"
    label={<><TextIcon /> Text</>}
    form={
      <>
        <InputField field="title" label="Title" />
        <TextareaField field="content" label="Content" />
      </>
    }
    children={
      <>
        <div className="flex">
          <div className="w-64 space-y-2">
            <h2 className="text-xl font-bold">
              <Field field="title" />
            </h2>
            <p>
              <Field field="content" />
            </p>
          </div>
        </div>
      </>
    }
  />

  <Block
    name="image"
    label={<><ImageIcon /> Image</>}
    form={
      <>
        <InputField field="title" label="Title" />
        <ImageField baseField="image" urlField="url" label="Image" />
      </>
    }
    children={
      <>
        <div className="flex">
          <div className="flex flex-col gap-2">
            <div className="space-y-2">
              <h2 className="text-xl font-bold">
                <Field field="title" />
              </h2>
              <div className="border">
                <HasOne field="image">
                  <UploadedImageView urlField="url" />
                </HasOne>
              </div>
            </div>
          </div>
        </div>
      </>
    }
  />

  <Block
    name="textWithImage"
    label={<><ColumnsIcon /> Image with text</>}
    form={
      <>
        <InputField field="title" label="Title" />
        <TextareaField field="content" label="Content" />
        <ImageField baseField="image" urlField="url" label="Image" />
        <RadioEnumField field="imagePosition" options={{ left: 'Left', right: 'Right' }} />
      </>
    }
  >
    <EntityView
      render={it => (
        <div className="flex">
          <div
            className={cn(
              'border border-gray-200',
              it.getField('imagePosition').value === 'right' ? 'order-2' : '',
            )}
          >
            <HasOne field="image">
              <UploadedImageView urlField="url" />
            </HasOne>
          </div>
          <div className="w-64 px-4 space-y-2">
            <h2 className="text-xl font-bold">
              <Field field="title" />
            </h2>
            <p>
              <Field field="content" />
            </p>
          </div>
        </div>
      )}
    />
  </Block>

  <Block
    name="hero"
    label={<><AlertOctagonIcon /> Hero</>}
    form={
      <>
        <InputField field="title" label="Title" />
        <TextareaField field="content" label="Content" />
        <InputField field="color" label="Color" inputProps={{ type: 'color' }} />
      </>
    }
  >
    <StaticRender>
      <Field field="color" />
    </StaticRender>
    <EntityView
      render={it => (
        <div className="flex">
          <div
            className="w-96 p-4 gap-2 flex flex-col items-center"
            style={{
              backgroundColor: it.getField<string>('color').value ?? undefined,
              color: getTextColor(it.getField<string>('color').value ?? ''),
            }}
          >
            <h2 className="text-4xl font-bold">
              <Field field="title" />
            </h2>
            <p className="text-xl">
              <Field field="content" />
            </p>
          </div>
        </div>
      )}
    />
  </Block>
</DefaultBlockRepeater>
```
Use this pattern when authors need a focused form for each block.

### Inline‑only repeater in a persisted entity tree
```tsx
import { DefaultBlockRepeater, Block } from '~/lib/block-repeater'

<Binding>
  <Slots.Title>
    <Title>Repeater: Block repeater w/o dual render</Title>
  </Slots.Title>

  <Slots.Actions>
    <PersistButton />
  </Slots.Actions>

  <EntitySubTree entity="BlockList(unique = unique)" setOnCreate="(unique = unique)">
    <DefaultBlockRepeater field="blocks" sortableBy="order" discriminationField="type">
      <Block name="text" label={<><TextIcon /> Text</>}>
        <InputField field="title" label="Title" />
        <TextareaField field="content" label="Content" />
      </Block>

      <Block name="image" label={<><ImageIcon /> Image</>}>
        <InputField field="title" label="Title" />
        <ImageField baseField="image" urlField="url" label="Image" />
      </Block>

      <Block
        name="textWithImage"
        label={
          <>
            <span className="inline-flex gap-1">
              <ImageIcon /> <TextIcon />
            </span>
            Image with text
          </>
        }
      >
        <InputField field="title" label="Title" />
        <TextareaField field="content" label="Content" />
        <ImageField baseField="image" urlField="url" label="Image" />
        <RadioEnumField field="imagePosition" options={{ left: 'Left', right: 'Right' }} />
      </Block>

      <Block name="hero" label={<><AlertOctagonIcon /> Hero</>}>
        <InputField field="title" label="Title" />
        <TextareaField field="content" label="Content" />
        <InputField field="color" label="Color" inputProps={{ type: 'color' }} />
      </Block>
    </DefaultBlockRepeater>
  </EntitySubTree>
</Binding>
```
Embed the repeater in any Contember binding context for instant persistence.

## Best Practices & Gotchas
* Always set `discriminationField`; omission breaks block recognition.
* Keep block previews lightweight—avoid heavy queries inside `children`.
* Use Tailwind `space-y-*` utilities for vertical rhythm between blocks.
* When many block types share fields, extract common forms into separate components.
* Sorting relies on `sortableBy`; ensure the underlying column exists in the schema.

## Further Reading
* Block component
* EntityView & StaticRender utilities
* Contember Form Binding basics
* Tailwind styling in Contember UI

<!-- End of Generated Documentation -->
