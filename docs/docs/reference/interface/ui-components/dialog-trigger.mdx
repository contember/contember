---
title: DialogTrigger
---

<!-- Edited by human: false -->
<!-- Examples count: 13 -->
<!-- Source examples: 0 -->
<!-- Playground examples: 3 -->
<!-- External examples: 10 -->
<!-- Import examples: 8 -->

# `DialogTrigger`

## Overview
`DialogTrigger` wraps an element that opens a `Dialog`.
You usually combine it with `asChild` to turn any button-like element into a trigger without adding extra DOM.

## Styling Guidelines
* All examples use Tailwind CSS utility classes.
* No Contember-specific theme classes are required for `DialogTrigger`.

## Core Concepts
* `DialogTrigger` must be a direct child of `Dialog`.
* The `asChild` prop lets you pass any single element (e.g. `Button`) and forwards events and refs.
* Without `asChild`, Contember renders a default `<button>` element.
* You can nest `DialogTrigger` inside other interactive wrappers such as `TooltipTrigger`.

## Quick Start
```tsx
import { Dialog, DialogContent, DialogTrigger } from '~/lib/ui/dialog'

export default function BasicDialog() {
	return (
		<Dialog>
			<DialogTrigger asChild>
				<button className="px-3 py-1 bg-blue-600 text-white rounded">
					Open dialog
				</button>
			</DialogTrigger>

			<DialogContent className="p-4">
				<p>Hello Dialog</p>
			</DialogContent>
		</Dialog>
	)
}
```

## Props Reference
| Name | Type | Required | Default | Description |
| --- | --- | --- | --- | --- |
| asChild | boolean | No | false | Renders the sole child element and forwards props instead of creating its own button. |
| …HTML button props | — | No | — | All standard `<button>` attributes are passed through when `asChild` is `false`. |

## Sub-Components / Building Blocks
### useDialogOpenState
A hook that returns the current open state and a setter. Use it for controlled dialogs.

## Examples

### Icon button with tooltip
```tsx
import { Dialog, DialogContent, DialogTrigger } from '~/lib/ui/dialog'
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '~/lib/ui/tooltip'
import { PencilIcon } from 'lucide-react'

() => (
	<TooltipProvider>
		<Dialog>
			<Tooltip>
				<TooltipTrigger asChild>
					<DialogTrigger asChild>
						<button className="p-1 rounded hover:bg-gray-100">
							<PencilIcon size={16} />
						</button>
					</DialogTrigger>
				</TooltipTrigger>

				<TooltipContent>Open editor</TooltipContent>
			</Tooltip>

			<DialogContent className="p-4">Editor form goes here…</DialogContent>
		</Dialog>
	</TooltipProvider>
)
```
Use `asChild` twice—once for the tooltip, once for the dialog—so the same button drives both behaviors.

### Data grid search dialog
```tsx
import { Dialog, DialogContent, DialogTrigger } from '~/lib/ui/dialog'
import { Button } from '~/lib/ui/button'
import { SearchIcon } from 'lucide-react'

() => (
	<Dialog>
		<DialogTrigger asChild>
			<Button className="gap-2">
				<SearchIcon /> Search
			</Button>
		</DialogTrigger>

		<DialogContent className="h-[60vh] overflow-auto">
			<DialogDataGrid />
		</DialogContent>
	</Dialog>
)
```
The trigger hides dialog complexity behind a single “Search” button. You can scroll inside the dialog without affecting the underlying page.

## Best Practices & Gotchas
* Always place `DialogTrigger` directly under `Dialog`. Nesting deeper breaks focus management.
* Wrap the actual clickable element with `asChild` to avoid extra `<button>` wrappers.
* Stop event propagation on the trigger if it sits inside another clickable area.
* When combining with `TooltipTrigger`, apply `asChild` to both components.

## Further Reading
* `Dialog`
* `DialogContent`
* `DialogClose`
* `useDialogOpenState`

<!-- End of Generated Documentation -->
