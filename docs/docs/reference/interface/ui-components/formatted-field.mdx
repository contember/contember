---
title: FormattedField
---

<!-- Edited by human: false -->
<!-- Examples count: 11 -->
<!-- Source examples: 1 -->
<!-- Playground examples: 0 -->
<!-- External examples: 10 -->
<!-- Import examples: 5 -->

# FormattedField

## Overview
`FormattedField` displays a field value formatted according to the schema definition.
You use it when you only need to show data, not edit it.

The component wraps `FieldView`, so it inherits all formatting rules (dates, numbers, enums) defined on the server.

## Styling Guidelines
* Every snippet below uses Tailwind CSS.
* The component itself requires no special Contember theme classes.

## Core Concepts
* Schema-driven formatting—values look exactly like in the administration UI.
* Accepts either a simple field name or an object with a relation path.
* Read-only by design; pair it with input components when you need editing.
* Works inside an `Entity` or `HasOne` context provided by Contember binding.

## Quick Start
```tsx
import { FormattedField } from '~/lib/field'

export const UserName = () => (
	<div className="text-sm text-gray-800">
		<FormattedField field="name" />
	</div>
)
```

## Detailed Guide
### Accessing nested relations
```tsx
// Displays `city` of the related `address`
<FormattedField field={{ field: 'city', hasOneRelationPath: ['address'] }} />
```
You can pass an object to travel through `hasOne` relations.
The example above calls `address.city` behind the scenes.

## Props Reference
| Name | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| field | `string` &#124; `{ field: string; hasOneRelationPath?: SugarableHasOneRelation &#124; SugarableHasOneRelation[] }` | Yes | – | The field to render. |

_Inherited props_ – None
## Examples
### Address overview
```tsx
<SectionBody className="grid grid-cols-1 md:grid-cols-3 gap-8">
	<div>
		<span className="font-medium text-gray-500">Address</span><br />
		<FormattedField field="line1" /> <FormattedField field="line2" />
	</div>
	<div>
		<span className="font-medium text-gray-500">City</span><br />
		<FormattedField field="city" />, <FormattedField field="state" /> <FormattedField field="postalCode" />
	</div>
	<div>
		<span className="font-medium text-gray-500">Country</span><br />
		<FormattedField field="country" />
	</div>
</SectionBody>
```
This snippet shows how you can combine multiple `FormattedField` components to render a full postal address.

### Heading with formatted name
```tsx
<h1 className="text-2xl font-semibold">
	<FormattedField field="name" />
</h1>
```
Use formatted fields directly inside headings or labels to keep typography consistent.

## Best Practices & Gotchas
* Place the component inside an `Entity` provider; otherwise, it cannot resolve the field.
* Do not use it for editing—pair it with input components instead.
* Keep relation paths short; deeply nested relations may impact query performance.
* Combine with Tailwind utility classes for tight control of spacing and colors.

## Further Reading
* `FieldView` – the lower-level display component.
* `EmailField` – specialized formatter for e-mail addresses.
* `HasOne` – provides relation context for nested fields.

<!-- End of Generated Documentation -->
