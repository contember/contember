---
title: RepeaterDropIndicator
---

<!-- Edited by human: false -->
<!-- Examples count: 12 -->
<!-- Source examples: 0 -->
<!-- Playground examples: 2 -->
<!-- External examples: 10 -->
<!-- Import examples: 6 -->

# RepeaterDropIndicator

## Overview
`RepeaterDropIndicator` shows users where a dragged repeater item will land.
It positions itself **before** or **after** the current item based on the `position` prop.

## Styling Guidelines
* All examples use Tailwind CSS utility classes.
* The component needs no special Contember theme classes.

## Core Concepts
* Drop indicators increase drag-and-drop clarity.
* `position` decides if the line renders above or below the item.
* You render the indicator inside every sortable repeater item.
* The component is visual only; it contains no drag logic.

## Quick Start
```tsx
import { RepeaterDropIndicator } from '~/lib/repeater'

export const SimpleDropZone = () => (
	<li className="relative">
		<RepeaterDropIndicator position="before" />
		<div className="p-4 bg-white shadow">Item content</div>
		<RepeaterDropIndicator position="after" />
	</li>
)
```

## Detailed Guide
Place the indicator at both ends of every sortable item.
Wrap the whole row in `relative` so the absolutely positioned line anchors correctly.

```tsx
const SortableItem = ({ children }: { children: ReactNode }) => (
	<li className="relative">
		<RepeaterDropIndicator position="before" />
		{children}
		<RepeaterDropIndicator position="after" />
	</li>
)
```

You usually combine it with `useSortable` or a similar hook:

```tsx
const { attributes, listeners, setNodeRef, transform, transition } = useSortable({ id })
```

Apply the returned attributes to your item, while the indicator handles only the visual focus state.

## Props Reference
| Name     | Type                    | Required | Default | Description                          |
|----------|-------------------------|----------|---------|--------------------------------------|
| position | `"before" \| "after"` | Yes      | —       | Where to render the drop indicator. |

_Inherited props: None_

## Sub-Components / Building Blocks
_None_

## Examples

### Playground – Drag-and-Drop Block Editor
```tsx
<Entity key={entity.key} accessor={entity}>
	<RepeaterCurrentEntityContext.Provider value={entity}>
		<RepeaterSortableItemContext.Provider value={sortable}>
			<div className="relative">
				<RepeaterDropIndicator position="before" />
				<RepeaterSortableItemNode>
					<div className="p-4 bg-white shadow">
						<RepeaterSortableItemActivator>
							<BlockEditorHandle />
						</RepeaterSortableItemActivator>
						{children}
					</div>
				</RepeaterSortableItemNode>
				<RepeaterDropIndicator position="after" />
			</div>
		</RepeaterSortableItemContext.Provider>
	</RepeaterCurrentEntityContext.Provider>
</Entity>
```
Explanation:
* `relative` ensures the indicator spans the full item width.
* Two instances cover both insertion points.
* Context providers keep the item reactive to order changes.

### Playground – Explicit Path Lookup
```tsx
{({ children, element }: { children: ReactNode; element: Element }) => {
	const editor = useSlateStatic()
	const sortedBlocks = useContext(SortedBlocksContext)
	const [index] = ReactEditor.findPath(editor, element)
	const entity = sortedBlocks[index]
	const sortable = useSortable({ id: entity?.id })

	return entity ? (
		<Entity key={entity.key} accessor={entity}>
			<RepeaterCurrentEntityContext.Provider value={entity}>
				<RepeaterSortableItemContext.Provider value={sortable}>
					<div className="relative">
						<RepeaterDropIndicator position="before" />
						<RepeaterSortableItemNode>
							<div className="p-4">
								<RepeaterSortableItemActivator>
									<BlockEditorHandle />
								</RepeaterSortableItemActivator>
								{children}
							</div>
						</RepeaterSortableItemNode>
						<RepeaterDropIndicator position="after" />
					</div>
				</RepeaterSortableItemContext.Provider>
			</RepeaterCurrentEntityContext.Provider>
		</Entity>
	) : (
		<div className="p-4">
			<BlockEditorHandle />
			{children}
		</div>
	)
}}
```
Explanation:
* Re-calculates the Slate path each render.
* The indicator usage stays identical; only surrounding lookup logic differs.

### Learning Platform – Block Repeater With Add-Item Button
```tsx
<RepeaterSortableEachItem>
	<div className="relative">
		<RepeaterDropIndicator position="before" />
		<RepeaterSortableItemNode>
			<BlockRepeaterItemUI>
				<RepeaterSortableItemActivator>
					<BlockRepeaterHandleUI />
				</RepeaterSortableItemActivator>
				<BlockRepeaterContent />
			</BlockRepeaterItemUI>
		</RepeaterSortableItemNode>
		<RepeaterDropIndicator position="after" />
		<BlockRepeaterAddItemBefore sortableBy={sortableBy} />
	</div>
</RepeaterSortableEachItem>
```
Explanation:
* Adds an “insert before” button right after the bottom indicator.
* Keeps the drag handle inside the activator.

### Learning Platform – Basic Repeater Wrapper
```tsx
<RepeaterSortable>
	<BlockRepeaterItemsWrapperUI>
		<RepeaterEmpty>
			<div className="italic text-sm text-gray-600">{dict.repeater.empty}</div>
		</RepeaterEmpty>
		{/* items rendered here */}
		<RepeaterSortableDragOverlay>
			<BlockRepeaterDragOverlayUI>
				<BlockRepeaterContent />
			</BlockRepeaterDragOverlayUI>
		</RepeaterSortableDragOverlay>
	</BlockRepeaterItemsWrapperUI>
</RepeaterSortable>
```
Explanation:
* Context wrapper around items; every item still contains two indicators.

### Learning Platform – Item With Actions And Handle
```tsx
<div className="relative">
	<RepeaterDropIndicator position="before" />
	<RepeaterSortableItemNode>
		<RepeaterItemUI>
			<RepeaterSortableItemActivator>
				<RepeaterHandleUI />
			</RepeaterSortableItemActivator>
			<RepeaterItemActions>
				<RepeaterRemoveItemButton />
			</RepeaterItemActions>
			{children}
		</RepeaterItemUI>
	</RepeaterSortableItemNode>
	<RepeaterDropIndicator position="after" />
</div>
```
Explanation:
* Shows how to mix drag handle and remove button within the item UI.

### Learning Platform – Readonly Repeater Wrapper
```tsx
<Repeater {...props}>
	<RepeaterSortable>
		<RepeaterSortableEachItem>
			<div className="relative">
				<RepeaterDropIndicator position="before" />
				<RepeaterSortableItemNode>
					<div>
						{!readonly && (
							<RepeaterSortableItemActivator>
								<RepeaterHandleUI />
							</RepeaterSortableItemActivator>
						)}
						{children}
					</div>
				</RepeaterSortableItemNode>
				<RepeaterDropIndicator position="after" />
			</div>
		</RepeaterSortableEachItem>
	</RepeaterSortable>
</Repeater>
```
Explanation:
* Hides the activator when the list is `readonly` but still renders both indicators.

### Block Repeater With Add-Item Button
```tsx
<RepeaterSortableEachItem>
	<div className="relative">
		<RepeaterDropIndicator position="before" />
		<RepeaterSortableItemNode>
			<BlockRepeaterItemUI>
				<RepeaterSortableItemActivator>
					<BlockRepeaterHandleUI />
				</RepeaterSortableItemActivator>
				<BlockRepeaterContent />
			</BlockRepeaterItemUI>
		</RepeaterSortableItemNode>
		<RepeaterDropIndicator position="after" />
		<BlockRepeaterAddItemBefore sortableBy={sortableBy} />
	</div>
</RepeaterSortableEachItem>
```
Explanation:
* Same pattern as the Learning Platform; proves consistency across projects.

### Basic Repeater Wrapper
```tsx
<RepeaterSortable>
	<BlockRepeaterItemsWrapperUI>
		<RepeaterEmpty>
			<div className="italic text-sm text-gray-600">{dict.repeater.empty}</div>
		</RepeaterEmpty>
		{/* items */}
	</BlockRepeaterItemsWrapperUI>
</RepeaterSortable>
```
Explanation:
* Simplest scaffold showing where items live.

### Item With Actions And Handle
```tsx
<div className="relative">
	<RepeaterDropIndicator position="before" />
	<RepeaterSortableItemNode>
		<RepeaterItemUI>
			<RepeaterSortableItemActivator>
				<RepeaterHandleUI />
			</RepeaterSortableItemActivator>
			{noRemove !== true && (
				<RepeaterItemActions>
					<RepeaterRemoveItemButton />
				</RepeaterItemActions>
			)}
			{children}
		</RepeaterItemUI>
	</RepeaterSortableItemNode>
	<RepeaterDropIndicator position="after" />
</div>
```
Explanation:
* Conditional remove button illustrates flexible layouts.

### Readonly Repeater Wrapper
```tsx
<Repeater {...props}>
	<RepeaterSortable>
		<RepeaterSortableEachItem>
			<div className="relative">
				<RepeaterDropIndicator position="before" />
				<RepeaterSortableItemNode>
					<div>
						{!readonly && (
							<RepeaterSortableItemActivator>
								<RepeaterHandleUI />
							</RepeaterSortableItemActivator>
						)}
						{children}
					</div>
				</RepeaterSortableItemNode>
				<RepeaterDropIndicator position="after" />
			</div>
		</RepeaterSortableEachItem>
	</RepeaterSortable>
</Repeater>
```
Explanation:
* Mirrors the Learning Platform version; confirms identical API usage.

## Best Practices & Gotchas
* Render both **before** and **after** indicators for consistent UX.
* Wrap the parent with `relative` positioning.
* Keep the indicator thin and high-contrast.
* Never attach drag logic to the indicator itself.
* Show indicators only during drag if visual noise becomes an issue.

## Further Reading
* `RepeaterSortableItemActivator` – handle for dragging.
* `RepeaterSortableItemNode` – wrapper that receives sortable props.
* `useSortable` – hook powering the reorder logic.

<!-- End of Generated Documentation -->
