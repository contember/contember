---
title: RichTextField
sidebar_label: RichTextField
---

<!-- Edited by human: false -->
<!-- Examples count: 3 -->

# RichTextField

## Overview
RichTextField embeds a rich‑text editor into a Contember form.  
It integrates with Contember’s field management and offers basic formatting like bold, italic, and code.

The editor relies on a plugin architecture, supports custom placeholders, and becomes read‑only during ongoing mutations.

## Styling Guidelines
* All code samples use Tailwind CSS.  
* No additional Contember theme classes are required by default.

## Core Concepts
* Form binding via the `field` prop.
* Plugin architecture for marks, elements, and toolbars.
* Read‑only lock while the form mutates.
* Optional custom placeholder text.
* Toolbar triggers must sit inside the editor to get context.

## Quick Start
```tsx
import { RichTextField } from '~/lib/editor'

<RichTextField field="content" className="max-w-md" />
```

## Detailed Guide
```tsx
import {
	RichTextField,
	EditorInlineToolbar,
	EditorMarkTrigger,
} from '~/lib/editor'
import {
	BoldIcon,
	ItalicIcon,
	UnderlineIcon,
	boldMark,
	italicMark,
	underlineMark,
} from '~/icons'

<RichTextField
	field="articleBody"
	label="Article body"
	placeholder="Enter your text here"
	className="space-y-2"
/>
```

```tsx
<RichTextField field="articleBody">
	<EditorInlineToolbar className="flex gap-2">
		<EditorMarkTrigger mark={boldMark}><BoldIcon className="h-4 w-4" /></EditorMarkTrigger>
		<EditorMarkTrigger mark={italicMark}><ItalicIcon className="h-4 w-4" /></EditorMarkTrigger>
		<EditorMarkTrigger mark={underlineMark}><UnderlineIcon className="h-4 w-4" /></EditorMarkTrigger>
	</EditorInlineToolbar>
</RichTextField>
```

## Props Reference
| Name | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| field | string &#124; { field: string; hasOneRelationPath?: SugarableHasOneRelation &#124; SugarableHasOneRelation[] } | Yes | — | Form field name for storing content |
| label | React.ReactNode | Yes | — | Visible label shown above the editor |
| description | React.ReactNode | Yes | — | Helper text rendered below the editor |
| errors | React.ReactNode &#124; ErrorAccessor.Error[] | Yes | — | Validation errors for the field |
| required | boolean | Yes | — | Marks the input as mandatory |
| children | React.ReactNode | Yes | — | Toolbar, triggers, or other custom nodes (inherited) |

## Sub-Components / Building Blocks
### EditorInlineToolbar
Interactive area that hosts formatting triggers.

### EditorMarkTrigger
Button that toggles a mark (e.g., bold, italic).

### EditorElementTrigger
Switches block‑level elements like links or headings.

### EditorGenericTrigger
Runs custom editor commands such as alignment changes.

### RichTextView
Read‑only renderer for stored rich text.

## Examples
### Full Form With Preview
```tsx
<Binding>
	<EntitySubTree entity="Article(id = 1)">
		<div className="space-y-4 max-w-2xl">
			<RichTextField field="body" label="Body text">
				<EditorInlineToolbar className="flex gap-2">
					<EditorMarkTrigger mark={boldMark}><BoldIcon className="h-3 w-3" /></EditorMarkTrigger>
					<EditorMarkTrigger mark={italicMark}><ItalicIcon className="h-3 w-3" /></EditorMarkTrigger>
				</EditorInlineToolbar>
			</RichTextField>

			<h3 className="text-lg font-medium">Preview</h3>
			<RichTextView field="body" className="prose" />
		</div>
	</EntitySubTree>
</Binding>
```
Stores rich text in the `body` field and instantly renders a preview.

### Rich Text With Alignment and Link
```tsx
<Binding>
	<Slots.Title>
		<Title icon={<PencilIcon />}>Rich text field</Title>
	</Slots.Title>

	<Slots.Actions>
		<PersistButton />
	</Slots.Actions>

	<EntitySubTree entity="EditorTextArea(unique = unique)" setOnCreate="(unique = unique)">
		<div className="space-y-4">
			<div className="max-w-md">
				<RichTextField field="data" label="Rich text field">
					<EditorInlineToolbar className="flex gap-2">
						<EditorMarkTrigger mark={boldMark}><Toggle><BoldIcon className="h-3 w-3" /></Toggle></EditorMarkTrigger>
						<EditorMarkTrigger mark={italicMark}><Toggle><ItalicIcon className="h-3 w-3" /></Toggle></EditorMarkTrigger>
						<EditorMarkTrigger mark={underlineMark}><Toggle><UnderlineIcon className="h-3 w-3" /></Toggle></EditorMarkTrigger>

						<EditorElementTrigger elementType={anchorElementType}><Toggle><LinkIcon className="h-3 w-3" /></Toggle></EditorElementTrigger>

						<EditorGenericTrigger {...createAlignHandler('start')}><Toggle><AlignLeftIcon className="h-3 w-3" /></Toggle></EditorGenericTrigger>
						<EditorGenericTrigger {...createAlignHandler('center')}><Toggle><AlignCenterIcon className="h-3 w-3" /></Toggle></EditorGenericTrigger>
						<EditorGenericTrigger {...createAlignHandler('end')}><Toggle><AlignRightIcon className="h-3 w-3" /></Toggle></EditorGenericTrigger>
					</EditorInlineToolbar>
				</RichTextField>
			</div>

			<h3>Preview</h3>
			<RichTextView field="data" />
		</div>
	</EntitySubTree>
</Binding>
```
Adds alignment controls and a link trigger. The preview below shows the stored content in real time.

## Best Practices & Gotchas
* Place toolbars inside `RichTextField` to gain editor context.
* Keep the editor in a `max-w-*` container to control layout.
* Avoid heavy plugins that bloat bundle size.
* Use `RichTextView` for display—never reuse the editing component.
* Wrap rich‑text editing inside a `Binding` context so mutations propagate.

## Further Reading
* BlockEditorField – block‑based editing.  
* PersistButton – saving entity data.  
* ErrorAccessor – advanced error handling.

<!-- End of Generated Documentation -->