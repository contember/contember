---
title: SelectDefaultPlaceholderUI
---

<!-- Edited by human: false -->
<!-- Examples count: 6 -->
<!-- Source examples: 0 -->
<!-- Playground examples: 0 -->
<!-- External examples: 6 -->
<!-- Import examples: 5 -->

## SelectDefaultPlaceholderUI

### Overview
SelectDefaultPlaceholderUI shows a muted “Select…” text when no option is chosen inside Contember select inputs.
You drop it wherever a placeholder should appear; it needs no props or configuration.

### Styling Guidelines
* All examples use Tailwind CSS utility classes.
* The component itself applies Contember’s `text-gray-500 italic` theme classes internally, so you rarely need extra styling.

### Core Concepts
* Placeholder appears only when the field has no value.
* You can replace or localize the placeholder by passing any React node instead of this component.
* Works with both single and multi-select inputs.
* It renders plain text, so it never triggers a popover or select action.

### Quick Start
```tsx
import { SelectInputUI, SelectDefaultPlaceholderUI } from '@contember/react-select'

export const StatusSelect = () => (
	<SelectInputUI className="w-full">
		{/* Placeholder shown until the user chooses a value */}
		<SelectDefaultPlaceholderUI />
	</SelectInputUI>
)
```

### Examples

#### Single-value select with icon
```tsx
<SelectInputUI id="priority" className="w-56">
	{selectedLabel ?? <SelectDefaultPlaceholderUI />}
	<SelectInputActionsUI>
		<ChevronDownIcon className="w-4 h-4" />
	</SelectInputActionsUI>
</SelectInputUI>
```
`selectedLabel` is rendered if a value exists; otherwise the placeholder appears.

#### Wrapped in SelectPlaceholder
```tsx
<SelectInputUI className="w-48">
	<SelectPlaceholder>
		<SelectDefaultPlaceholderUI />
	</SelectPlaceholder>
	{/* other select elements go here */}
</SelectInputUI>
```
Using `SelectPlaceholder` lets you keep layout consistent while conditionally hiding the placeholder.

#### Custom form field with Popover
```tsx
({ field, label, description, options, placeholder }) => {
	const [open, setOpen] = useState(false)
	const fieldAccessor = useField<string>(field)

	return (
		<FormFieldScope field={field}>
			<FormContainer description={description} label={label}>
				<Popover open={open} onOpenChange={setOpen}>
					<PopoverTrigger asChild>
						<SelectInputUI className="w-full">
							{fieldAccessor.value
								? options[fieldAccessor.value]
								: (placeholder ?? <SelectDefaultPlaceholderUI />)}
							<SelectInputActionsUI>
								{open
									? <ChevronUpIcon className="w-4 h-4" />
									: <ChevronDownIcon className="w-4 h-4" />}
							</SelectInputActionsUI>
						</SelectInputUI>
					</PopoverTrigger>

					<SelectPopoverContent>
						{Object.entries(options).map(([value, label]) => (
							<SelectListItemUI
								key={value}
								onClick={() => {
									fieldAccessor.updateValue(value)
									setOpen(false)
								}}
							>
								{label}
							</SelectListItemUI>
						))}
					</SelectPopoverContent>
				</Popover>
			</FormContainer>
		</FormFieldScope>
	)
}
```
The component acts as a fallback when no `placeholder` prop is supplied, keeping the field usable without extra work.

### Best Practices & Gotchas
* Keep the placeholder short; long texts push icons outside the input.
* Swap the component for localized text instead of mutating it.
* Do not attach event handlers; the component is purely visual.
* Avoid extra wrapping elements—use it directly inside select input bodies where possible.

### Further Reading
* SelectInputUI
* SelectPlaceholder
* SelectPopoverContent
* Contember Form Fields documentation

<!-- End of Generated Documentation -->
