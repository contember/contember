---
title: SidebarMenuSub
---

<!-- Edited by human: false -->
<!-- Examples count: 2 -->
<!-- Source examples: 0 -->
<!-- Playground examples: 0 -->
<!-- External examples: 2 -->
<!-- Import examples: 2 -->

# SidebarMenuSub

## Overview
SidebarMenuSub renders a nested group of sidebar menu items.  
You use it inside a collapsible menu to display second-level navigation.

## Styling Guidelines
* All examples use Tailwind CSS.  
* No special Contember theme classes are required; inherit styles from parent `SidebarMenu`.

## Core Concepts
* SidebarMenuSub groups child items and adds proper indentation.  
* It relies on the surrounding `SidebarMenu` context.  
* Use it only inside a collapsible area or another menu item.  
* Combine with `SidebarMenuSubItem` and `SidebarMenuSubButton` for consistent UX.

## Quick Start
```tsx
import {
	SidebarMenu,
	SidebarMenuItem,
	SidebarMenuButton,
	SidebarMenuSub,
	SidebarMenuSubItem,
	SidebarMenuSubButton,
} from '~/lib/ui/sidebar'

export const AppSidebar = () => (
	<SidebarMenu className="w-64 bg-gray-800 text-white">
		<SidebarMenuItem>
			<SidebarMenuButton className="flex w-full items-center gap-2 px-4 py-2 hover:bg-gray-700">
				Dashboard
			</SidebarMenuButton>
		</SidebarMenuItem>

		<SidebarMenuItem>
			<SidebarMenuButton className="flex w-full items-center gap-2 px-4 py-2 hover:bg-gray-700">
				Projects
			</SidebarMenuButton>

			{/* Nested level */}
			<SidebarMenuSub className="ml-6">
				<SidebarMenuSubItem>
					<SidebarMenuSubButton className="block w-full px-4 py-2 hover:bg-gray-700">
						Active
					</SidebarMenuSubButton>
				</SidebarMenuSubItem>
				<SidebarMenuSubItem>
					<SidebarMenuSubButton className="block w-full px-4 py-2 hover:bg-gray-700">
						Archived
					</SidebarMenuSubButton>
				</SidebarMenuSubItem>
			</SidebarMenuSub>
		</SidebarMenuItem>
	</SidebarMenu>
)
```

## Detailed Guide
_None_

## Props Reference
_None_

## Sub-Components / Building Blocks
### SidebarMenuSubItem
Thin wrapper for a single item inside `SidebarMenuSub`.

### SidebarMenuSubButton
Clickable element placed inside `SidebarMenuSubItem`.

## Examples
```tsx
({ lvl, icon, label, children, defaultOpen = false }: Omit<MenuItem<any>, 'isAllowed'> & { lvl: number }) => {
	const hasActiveChild = useHasActiveChild(children)
	const key = `${label?.toString()}-${lvl}`
	const menu = useOpenedItemsContext()
	const { color } = useCompanyCustomization()

	useEffect(() => {
		if (defaultOpen || hasActiveChild) {
			menu?.setMenuCollapsibleState(prev => ({ ...prev, openedItems: [...new Set([...prev.openedItems, key])] }))
		}
	}, [defaultOpen, key, hasActiveChild])

	const isOpen = menu?.menuCollapsibleState.openedItems.includes(key) &&
		!menu?.menuCollapsibleState.closedItems.some(it => it === key)

	return (
		<Collapsible
			open={isOpen}
			onOpenChange={value =>
				menu?.setMenuCollapsibleState(prev => ({
					openedItems: value ? [...prev.openedItems, key] : prev.openedItems.filter(it => it !== key),
					closedItems: value ? prev.closedItems.filter(it => it !== key) : [...prev.closedItems, key],
				}))
			}
			className="group/collapsible"
		>
			<SidebarMenuItem>
				<CollapsibleTrigger asChild>
					<SidebarMenuButton>
						{icon}
						<span>{label}</span>
						{children && (
							<span className="ml-auto">
								{isOpen
									? <ChevronDown className="h-4 w-4" color={color} />
									: <ChevronRight className="h-4 w-4" color={color} />}
							</span>
						)}
					</SidebarMenuButton>
				</CollapsibleTrigger>

				<CollapsibleContent>
					<MenuContext.Provider value={{ level: lvl + 1 }}>
						<SidebarMenuSub>{children}</SidebarMenuSub>
					</MenuContext.Provider>
				</CollapsibleContent>
			</SidebarMenuItem>
		</Collapsible>
	)
}
```
This pattern shows how you keep a sub-menu open when one of its descendants is active.  
`SidebarMenuSub` hosts the nested items inside `CollapsibleContent`.

## Best Practices & Gotchas
* Render `SidebarMenuSub` only when you actually have nested items.  
* Add left margin (`ml-*`) so nested items align visually.  
* Combine with `Collapsible` to toggle visibility instead of conditionally rendering.  
* Avoid deep nesting beyond two levels; usability suffers.  
* Keep button widths consistent (`w-full`) to keep click targets predictable.

## Further Reading
* SidebarMenu  
* SidebarMenuItem  
* SidebarMenuButton  
* Collapsible (from Radix)  

<!-- End of Generated Documentation -->