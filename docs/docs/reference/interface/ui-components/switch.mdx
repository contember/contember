---
title: Switch
---

<!-- Edited by human: false -->
<!-- Examples count: 10 -->
<!-- Source examples: 0 -->
<!-- Playground examples: 0 -->
<!-- External examples: 10 -->
<!-- Import examples: 5 -->

## Overview
`Switch` renders an accessible toggle that controls a boolean value.  
You can use it in controlled or uncontrolled mode by passing either `checked` or `defaultChecked`.

## Styling Guidelines
* All snippets use Tailwind CSS classes.  
* Add `data-[state=checked]:bg-primary` (from the Contember theme) when you need a themed “on” color.

## Core Concepts
* Controlled vs. uncontrolled switches.
* Handling the `onCheckedChange` callback.
* Combining a switch with labels, badges, or form fields.
* Persisting changes to Contember with `usePersist()` or form accessors.

## Quick Start
```tsx
import { Switch } from '~/lib/ui/switch'

export const ToggleNotifications = () => {
	const [enabled, setEnabled] = useState(false)

	return (
		<div className="flex items-center gap-2">
			<Switch checked={enabled} onCheckedChange={setEnabled} />
			<span className="text-sm">{enabled ? 'Notifications on' : 'Notifications off'}</span>
		</div>
	)
}
```

## Detailed Guide
_None_

## Props Reference
| Name | Type | Required | Default | Description |
|------|------|----------|---------|-------------|
| checked | boolean | No | — | Controlled value. |
| defaultChecked | boolean | No | false | Initial value for uncontrolled mode. |
| onCheckedChange | (checked: boolean) => void | No | — | Fires whenever the value changes. |
| className | string | No | — | Tailwind or custom classes. |
| …HTMLDivProps | — | No | — | All other props are forwarded to the root element. |

## Sub-Components / Building Blocks
_None_

## Examples

### 1. Persisting entity existence
```tsx
const entity = useEntity()
const relation = entity.getEntity(field)
const isOpen = relation.existsOnServer || relation.hasUnpersistedChanges

<Switch
	defaultChecked={isOpen}
	onCheckedChange={checked => {
		if (checked) relation.getField('data').updateValue('{}')
		else relation.deleteEntity()
		persist()
	}}
/>
```
The switch adds or removes a related entity and persists the change.

### 2. Bulk activation dialog
```tsx
const [isActive, setIsActive] = useState(false)

<Switch
	checked={isActive}
	onCheckedChange={setIsActive}
	className="data-[state=checked]:bg-primary"
/>
```
`data-[state=checked]:bg-primary` applies your theme’s primary color only when the switch is on.

### 3. Inline yes/no selector
```tsx
<div className="flex gap-2 items-center text-xs">
	<span>No</span>
	<Switch checked={value} onCheckedChange={setValue} />
	<span>Yes</span>
</div>
```
A compact boolean selector for lists or tables.

## Best Practices & Gotchas
* Pass **either** `checked` **or** `defaultChecked`, never both.
* Always handle `onCheckedChange` when working in controlled mode.
* Use semantic labels for accessibility (`aria-label` or adjacent text).
* Style the “on” state with `data-[state=checked]:bg-*` instead of toggling classes manually.
* Wrap the switch and label in `flex items-center gap-2` for proper alignment.

## Further Reading
* `Button` – for clickable actions next to a switch.
* `Dialog` – combine with switches inside modals.
* Contember docs on `usePersist` and entity relations.

<!-- End of Generated Documentation -->