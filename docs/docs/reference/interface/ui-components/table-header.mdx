---
title: TableHeader
---

<!-- Edited by human: false -->
<!-- Examples count: 12 -->
<!-- Source examples: 0 -->
<!-- Playground examples: 2 -->
<!-- External examples: 10 -->
<!-- Import examples: 7 -->

## Overview  
_None_

## Styling Guidelines  
* All snippets use Tailwind CSS.  
* No additional Contember theme classes are required for `TableHeader`.

## Core Concepts  
* `TableHeader` wraps one or more `TableRow` elements.  
* Place it directly inside `Table` before `TableBody`.  
* Combine with `TableHead` for individual header cells.  
* Keep the component purely structural—put styles on `TableHead` or `TableRow`.

## Quick Start
```tsx
import { Table, TableHeader, TableRow, TableHead } from '~/lib/ui/table'

export const BasicTable = () => (
	<Table className="w-full text-sm">
		<TableHeader>
			<TableRow className="bg-gray-100">
				<TableHead className="px-3 py-2">Name</TableHead>
				<TableHead className="px-3 py-2">Email</TableHead>
				<TableHead className="px-3 py-2">Role</TableHead>
			</TableRow>
		</TableHeader>
		{/* <TableBody>…</TableBody> */}
	</Table>
)
```

## Detailed Guide  
_None_

## Props Reference  
_None_

## Sub-Components / Building Blocks  
_None_

## Examples  

### ACL-Aware Table  
The header defines two permission columns and an input column. The body is driven by Contember data bindings.
```tsx
<Table>
	<TableHeader>
		<TableRow>
			<TableHead>canRead</TableHead>
			<TableHead>canEdit</TableHead>
			<TableHead>input</TableHead>
		</TableRow>
	</TableHeader>
	<TableBody>
		<EntityListSubTree entities="AclRestrictedValue">
			<TableRow>
				<TableCell><Field field="canRead" format={formatBoolean} /></TableCell>
				<TableCell><Field field="canEdit" format={formatBoolean} /></TableCell>
				<TableCell><AclAwareInputField field="primaryValue" /></TableCell>
			</TableRow>
		</EntityListSubTree>
	</TableBody>
</Table>
```
**Why it matters:** You keep permission-related columns grouped and readable while Contember handles data security.

### Editable Factors List  
You can mix static widths with flexible columns.
```tsx
<Table>
	<TableHeader>
		<TableRow>
			<TableHead className="w-64">Factor</TableHead>
			<TableHead className="w-32" />
			<TableHead className="w-48">Class</TableHead>
			<TableHead>Note</TableHead>
		</TableRow>
	</TableHeader>
	<TableBody>
		<HasMany field="factors" orderBy="factor.order asc">
			<JobFactorForm />
		</HasMany>
	</TableBody>
</Table>
```
**Why it matters:** Fixed widths keep key columns aligned across pages.

## Best Practices & Gotchas  
* Keep exactly one `TableHeader` per table for valid semantics.  
* Avoid putting interactive elements (buttons, inputs) inside `TableHeader`; reserve them for `TableBody`.  
* Style the background at the `TableRow` level to affect all header cells consistently.  
* Apply responsive classes (`hidden md:table-cell`) directly on `TableHead` when you need column hiding.

## Further Reading  
* `Table` – container component.  
* `TableBody` – body section for data rows.  
* `TableRow` – structural row element.  
* `TableHead` – header cell element.

<!-- End of Generated Documentation -->