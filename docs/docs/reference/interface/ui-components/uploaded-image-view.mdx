## Overview
`UploadedImageView` shows an already–uploaded image that lives inside a Contember entity.  
You give it the field holding the file URL and it renders an `<img>` with optional action buttons.

## Core Concepts
* Contember stores each file attribute (URL, width, …) in a separate field.
* You usually place the component inside `<HasOne>` or `<RepeaterField>` so it gets entity context.
* The component is read-only by default.  
  Supply `actions`, `edit`, or `DestroyAction` if you need inline editing.
* It never uploads or deletes files on its own. You wire those behaviours in higher-level components.

## Installation
```tsx
// any React file
import { UploadedImageView } from '~/lib/upload'
// or
import { UploadedImageView } from '@app/lib/upload'
```

## Quick Start
```tsx
import { HasOne } from '@contember/admin'
import { UploadedImageView } from '~/lib/upload'

<HasOne field="image">
  <UploadedImageView urlField="url" className="w-48 h-48 object-cover rounded" />
</HasOne>
```

## Detailed Guide
1. Wrap the component in a binding component that provides entity context:
   ```tsx
   <HasOne field="image">
     <UploadedImageView urlField="url" />
   </HasOne>
   ```
2. Add more metadata fields when you need them for captions or tooltips:
   ```tsx
   <UploadedImageView
     urlField="url"
     fileNameField="fileName"
     widthField="width"
     heightField="height"
   />
   ```
3. Inject custom actions:
   ```tsx
   <UploadedImageView
     urlField="url"
     actions={<MyReplaceButton />}
     DestroyAction={RepeaterRemoveItemTrigger}
   />
   ```

## Component API Reference

### Main Component – `UploadedImageView`
Shows an image referenced by the given field.  
You may also read other metadata fields or render custom action buttons.

#### Props
<!-- props -->

<!-- No sub-components in this group -->

## Hooks
*(none)*

## Examples

### Basic preview
```tsx
<HasOne field="image">
  <UploadedImageView urlField="url" />
</HasOne>
```

### Conditional column order
```tsx
it => (
  <div className="flex">
    <div
      className={cn(
        'border border-gray-200',
        it.getField('imagePosition').value === 'right' ? 'order-2' : ''
      )}
    >
      <HasOne field="image">
        <UploadedImageView urlField="url" />
      </HasOne>
    </div>
    <div className="w-64 px-4 space-y-2">
      <h2 className="text-xl font-bold">
        <Field field="title" />
      </h2>
      <p>
        <Field field="content" />
      </p>
    </div>
  </div>
)
```

### Selectable grid item
```tsx
it => (
  <div
    className="relative border rounded border-gray-200 shadow hover:shadow-md hover:border-yellow-500"
    onClick={() => {
      it && connect(it)
      closeOnSelect && setOpen(false)
    }}
  >
    <UploadedImageView {...imageFields} />
  </div>
)
```

### Repeater with checkbox and custom destroy
```tsx
<ImageRepeaterField
  field="photos"
  urlField="image.url"
  sortableBy="order"
  withoutUploader
>
  <div className="relative">
    <div className="absolute top-1 right-1 z-10 bg-white/80 py-0.5 px-1 rounded">
      <CheckboxField field="isUsed" label="Use image" />
    </div>

    <UploadedImageView
      urlField="image.url"
      DestroyAction={RepeaterRemoveItemTrigger}
    />
  </div>
</ImageRepeaterField>
```

## Best Practices & Gotchas
* Always wrap the component in an entity provider like `<HasOne>` or `<RepeaterField>`.
* Store all image metadata in the same entity to avoid deep relation paths.
* Use `DestroyAction` to prevent accidental deletes when multiple editors work together.
* Disable the default destroy icon with `noDestroy` if you rely on your own control.
* Combine Tailwind classes to keep images responsive (`className="max-w-full h-auto"`).

## Further Reading
* `HasOne` and `RepeaterField` – provide entity context.
* `UploaderDropzoneAreaUI` – handle the upload flow.
* Contember Admin binding documentation.

<!-- End of Generated Documentation -->

> **Note:** Props reference has been automatically enhanced with precise API types from API Extractor.
