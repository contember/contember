---
title: usePersistFeedbackHandlers
---

<!-- Edited by human: false -->
<!-- Examples count: 1 -->

# usePersistFeedbackHandlers

## Overview
`usePersistFeedbackHandlers` is a React hook that centralizes persistence‑related feedback.  
You receive handlers—currently only a success handler—to plug into any async workflow.

## Styling Guidelines
* All examples use Tailwind CSS.
* The hook needs no Contember theme classes.

## Core Concepts
* Keep feedback logic outside UI components.  
* Reuse a single success handler across mutations.  
* Compose the handler with any `Promise`‑returning function.

## Quick Start
```tsx
import { usePersistFeedbackHandlers } from '@contember/react'

export const SaveButton = () => {
	const { onPersistSuccess } = usePersistFeedbackHandlers()

	const handleClick = () => {
		persistData().then(onPersistSuccess)
	}

	return (
		<button
			onClick={handleClick}
			className="px-4 py-2 bg-blue-600 text-white rounded"
		>
			Save
		</button>
	)
}
```

## Detailed Guide
_None_

## Props Reference
_None_

## Sub-Components / Building Blocks
### onPersistSuccess
A callback that runs after a successful persistence.  
You usually fire a toast or route away inside this handler.

## Examples

### Basic usage
```tsx
const { onPersistSuccess } = usePersistFeedbackHandlers()

persistData().then(onPersistSuccess)
```
Pass the handler directly to the promise for a one‑liner feedback solution.

### Integrating with a form submit
```tsx
const { onPersistSuccess } = usePersistFeedbackHandlers()

const handleSubmit = async (values: FormValues) => {
	await saveForm(values).then(onPersistSuccess)
}
```
Your form stays slim while feedback remains consistent across pages.

### Chaining multiple async calls
```tsx
const { onPersistSuccess } = usePersistFeedbackHandlers()

const handleComplexSave = async () => {
	await uploadAssets()
	await saveMetadata().then(onPersistSuccess)
}
```
You can call the handler in any branch, avoiding duplicated toast logic.

## Best Practices & Gotchas
* Call the handler only after the promise resolves.  
* Keep the handler side‑effect focused; do not mutate unrelated state.  
* Memoize long callbacks with `useCallback` when passing them to children.  
* Plan for future error or loading handlers; the hook may expand.

## Further Reading
* `usePersistWithFeedback`
* Contember form hooks
* Toast and notification patterns in your design system

<!-- End of Generated Documentation -->