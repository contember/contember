import OpenAI from 'openai'
import type { AIPromptData, ComponentOverride, DocsConfig } from './types'

// Initialize OpenAI client
// The client automatically picks up the OPENAI_API_KEY environment variable.
const openai = new OpenAI()

/**
 * Constructs the prompt string to be sent to the AI model.
 *
 * @param data - The aggregated source data for the component.
 * @param override - Optional component-specific overrides.
 * @returns The formatted prompt string.
 */
function buildPrompt(data: AIPromptData, override?: ComponentOverride): string {
	// Start with the base instruction
	let prompt = `You are an expert technical writer specializing in React component documentation for a Docusaurus website. Based on the JSDoc, API data, and examples below, generate comprehensive, human-readable documentation for the component.

Follow this structure:
- Overview (based on JSDoc description)
- Props Table (Name, Type, Description, Default - make descriptions clear and concise)
- Requirements (if mentioned in JSDoc or implied)
- Features (highlight key capabilities)
- Usage Examples (reformat provided examples with explanations)
- When to Use / When Not to Use (provide guidance based on the component's purpose)

--- Template ---

# Component Name

## Overview
Brief high‑level description of what the component does and the most common use‑cases.

*One or two paragraphs are usually enough.*

---

## Core Concepts
Explain key ideas that the reader must understand before jumping into the API (e.g. internal vs displayed state, persistence strategies, composition philosophy).

Use bullet lists or short paragraphs. Keep it concise but actionable.

---

## Quick Start
\`\`\`tsx
// Minimal yet functional example that readers can copy & paste.
// Focus on the simplest realistic scenario.
\`\`\`

---

## Detailed Guide (optional)
Walk the reader through a real‑world scenario step‑by‑step. Feel free to use multiple code snippets and explanations.

---

## Props Reference
| Name | Type | Default | Description |
| ---- | ---- | ------- | ----------- |
| &nbsp; | &nbsp; | &nbsp; | List every public prop, including inherited ones. |

*Tip: keep the table in sync with the TypeScript declaration file.*

---

## Sub‑Components / Building Blocks

### Filters (if applicable)
Document every built‑in filter type in its own sub‑section so that the page can be long‑scanned. Follow this pattern:

#### \`DataViewTextFilter\`
\`\`\`tsx
<DataViewTextFilter name="query" field="title" />
\`\`\`

1–2 sentences explaining what the filter does, followed by **Props** if relevant.

Repeat for all other filter types (Boolean, Number, Date, Enum, Relation, …).

### Triggers (if applicable)
Same pattern as Filters.

### Hooks
Briefly describe each hook and its most important return values. Prefer short code samples over prose.

---

## Examples
### Example 1 – Title
\`\`\`tsx
// code
\`\`\`
Explanation.

You can include multiple focused examples (paging, infinite scroll, keyboard navigation, …). Keep each one self‑contained.

---

## Best Practices & Gotchas
Bullet‑point list of recommendations and common pitfalls.

---

## Full API Reference
If the component exposes many advanced hooks/types, link to autogenerated API docs or TypeScript declarations.

---

## Further Reading
Link to related components, concepts or external resources.

--- Component Data ---

## Component
${data.componentName}
`

	// Add JSDoc description if available
	if (data.jsdoc) {
		prompt += `\n## Description (from JSDoc)\n${data.jsdoc}\n`
	} else {
		prompt += `\n## Description (from JSDoc)\nNo JSDoc description provided.\n`
	}

	// Add API Props if available
	if (data.props && Object.keys(data.props).length > 0) {
		prompt += `\n## API Props (from API Extractor / Type Analysis)\n`
		prompt += `\`\`\`json\n{\n`
		for (const [propName, propData] of Object.entries(data.props)) {
			prompt += `  "${propName}": {\n`
			prompt += `    "type": "${propData.type}",\n`
			if (propData.description) {
				// Escape quotes in description for JSON validity, although it's illustrative here
				prompt += `    "description": "${propData.description?.replace(/"/g, '\\"')}",\n`
			}
			if (propData.required !== undefined) {
				prompt += `    "required": ${propData.required},\n`
			}
			if (propData.defaultValue !== undefined) {
				prompt += `    "defaultValue": "${propData.defaultValue?.replace(/"/g, '\\"')}",\n`
			}
			// Remove trailing comma from the last property within the prop object
			prompt = prompt.trim().replace(/,$/, '') + '\n'
			prompt += `  },\n`
		}
		// Remove trailing comma from the last prop entry in the main object
		prompt = prompt.trim().replace(/,$/, '') + '\n'
		prompt += `}\n\`\`\`\n`
	} else {
		prompt += `\n## API Props (from API Extractor / Type Analysis)\nNo props data provided or extracted.\n`
	}

	// Add Examples if available
	if (data.examples && data.examples.length > 0) {
		prompt += `\n## Examples (from source)\n`
		data.examples.forEach((example, index) => {
			prompt += `\`\`\`tsx\n${example}\n\`\`\`\n${index < data.examples!.length - 1 ? '\n' : ''}` // Add newline between examples
		})
	} else {
		prompt += `\n## Examples (from source)\nNo examples provided.\n`
	}

	// Add override notes if available
	if (override?.notes) {
		prompt += `\n## Additional Notes/Context\n${override.notes}\n`
	}

	prompt += `\n--- Generated Documentation ---`

	return prompt
}

/**
 * Generates Markdown documentation for a component using an AI model.
 *
 * @param sourceData - The aggregated source data for the component.
 * @param override - Optional component-specific overrides from config.
 * @param aiConfig - Optional AI configuration from config.
 * @returns A promise that resolves to the generated Markdown string, or null on failure.
 */
export async function generateMarkdownWithAI(
	sourceData: AIPromptData,
	override?: ComponentOverride,
	aiConfig?: DocsConfig['ai'],
): Promise<string | null> {
	const prompt = buildPrompt(sourceData, override)
	const model = aiConfig?.model || 'gpt-3.5-turbo' // Use configured model or default

	// --- Optional: Log the prompt for debugging ---
	// console.log(`\n--- AI Prompt for ${sourceData.componentName} ---`);
	// console.log(prompt);
	// console.log(`--- End AI Prompt ---`);
	// ---

	try {
		const completion = await openai.chat.completions.create({
			model: model,
			messages: [
				{
					role: 'system',
					content: 'You are an expert technical writer generating Markdown documentation for React components for a Docusaurus site.',
				},
				{ role: 'user', content: prompt },
			],
			// Optional parameters (adjust as needed):
			// temperature: 0.7, // Controls randomness (0.0 to 2.0)
			// max_tokens: 1500, // Max length of the generated response
			// top_p: 1.0,
			// frequency_penalty: 0.0,
			// presence_penalty: 0.0,
		})

		const content = completion.choices[0]?.message?.content

		if (!content) {
			console.error(`AI response for ${sourceData.componentName} was empty.`)
			return null
		}

		// --- Basic Post-processing (Optional) ---
		// You might want to add logic here to clean up the AI's output,
		// ensure the frontmatter is correct, etc.
		let finalContent = content.trim()

		// Add Docusaurus frontmatter (if the AI didn't include it reliably)
		const title = override?.title || sourceData.componentName
		const sidebarLabel = sourceData.componentName
		const frontmatter = `---
title: ${title}
sidebar_label: ${sidebarLabel}
---

`

		// Add frontmatter if it's not already present
		if (!finalContent.startsWith('---')) {
			finalContent = frontmatter + finalContent
		}


		return finalContent

	} catch (error) {
		console.error(`Error calling OpenAI API for ${sourceData.componentName}:`, error)
		// Consider more specific error handling (e.g., rate limits, auth errors)
		return null // Indicate failure
	}
}
